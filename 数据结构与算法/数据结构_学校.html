<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据结构（学校） | Francis-xsc</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/assets/img/favicon.ico">
    <meta name="description" content="徐思崇">
    <meta name="author" href="Francis-xsc">
    <link rel="preload" href="/assets/css/0.styles.6b7c271b.css" as="style"><link rel="preload" href="/assets/js/app.a5ec0a2d.js" as="script"><link rel="preload" href="/assets/js/2.785c97dd.js" as="script"><link rel="preload" href="/assets/js/22.01a3eb25.js" as="script"><link rel="prefetch" href="/assets/js/10.ad541554.js"><link rel="prefetch" href="/assets/js/11.4ef84df1.js"><link rel="prefetch" href="/assets/js/12.a78e1bb6.js"><link rel="prefetch" href="/assets/js/13.9b030b75.js"><link rel="prefetch" href="/assets/js/14.a417bbc1.js"><link rel="prefetch" href="/assets/js/15.ecabb56f.js"><link rel="prefetch" href="/assets/js/16.216857e5.js"><link rel="prefetch" href="/assets/js/17.dde2a7cb.js"><link rel="prefetch" href="/assets/js/18.04704f8d.js"><link rel="prefetch" href="/assets/js/19.7f14631d.js"><link rel="prefetch" href="/assets/js/20.602915c9.js"><link rel="prefetch" href="/assets/js/21.98bfad00.js"><link rel="prefetch" href="/assets/js/23.48ede5bc.js"><link rel="prefetch" href="/assets/js/24.97e54fe0.js"><link rel="prefetch" href="/assets/js/25.41e29e25.js"><link rel="prefetch" href="/assets/js/26.798a511f.js"><link rel="prefetch" href="/assets/js/27.99bf2ebc.js"><link rel="prefetch" href="/assets/js/28.893b543f.js"><link rel="prefetch" href="/assets/js/29.5a462b04.js"><link rel="prefetch" href="/assets/js/3.bff38b48.js"><link rel="prefetch" href="/assets/js/30.606c4725.js"><link rel="prefetch" href="/assets/js/31.3c34f459.js"><link rel="prefetch" href="/assets/js/32.7a04a839.js"><link rel="prefetch" href="/assets/js/33.f0160151.js"><link rel="prefetch" href="/assets/js/34.33a3b310.js"><link rel="prefetch" href="/assets/js/35.508b6360.js"><link rel="prefetch" href="/assets/js/4.71453c45.js"><link rel="prefetch" href="/assets/js/5.5fc371a9.js"><link rel="prefetch" href="/assets/js/6.42ef6059.js"><link rel="prefetch" href="/assets/js/7.2febbb17.js"><link rel="prefetch" href="/assets/js/8.5566e199.js"><link rel="prefetch" href="/assets/js/9.ec62d861.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6b7c271b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/img/logo.png" alt="Francis-xsc" class="logo"> <span class="site-name can-hide">Francis-xsc</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  Guide
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">数据结构与算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">数据结构与算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/数据结构与算法/大话数据结构/" class="nav-link">
  大话数据结构
</a></li><li class="dropdown-item"><!----> <a href="/数据结构与算法/哈学院算法培训/" class="nav-link">
  哈学院算法培训
</a></li><li class="dropdown-item"><!----> <a href="/数据结构与算法/快速幂算法 牛客小白月赛 1-C分元宵/" class="nav-link">
  快速幂算法
</a></li><li class="dropdown-item"><!----> <a href="/数据结构与算法/数据结构_邓俊辉/" class="nav-link">
  数据结构_邓俊辉
</a></li><li class="dropdown-item"><!----> <a href="/数据结构与算法/数据结构_学校/" class="nav-link">
  数据结构(学校）
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/语言/文件读写/" class="nav-link">
  文件读写
</a></li><li class="dropdown-item"><!----> <a href="/语言/哈学院算法培训/" class="nav-link">
  哈学院算法培训
</a></li><li class="dropdown-item"><!----> <a href="/语言/Java/" class="nav-link">
  Java
</a></li><li class="dropdown-item"><!----> <a href="/语言/Javascript/" class="nav-link">
  Javascript
</a></li><li class="dropdown-item"><!----> <a href="/语言/python-北理工/" class="nav-link">
  python
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">乱七八糟</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">乱七八糟</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/乱七八糟/乱七八糟/" class="nav-link">
  乱七八糟
</a></li><li class="dropdown-item"><!----> <a href="/乱七八糟/虚拟机安装凤凰OS/" class="nav-link">
  虚拟机安装凤凰OS
</a></li><li class="dropdown-item"><!----> <a href="/乱七八糟/数据库/" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/乱七八糟/国内访问GitHub/" class="nav-link">
  国内访问GitHub
</a></li><li class="dropdown-item"><!----> <a href="/乱七八糟/Markdown/" class="nav-link">
  Markdown
</a></li><li class="dropdown-item"><!----> <a href="/乱七八糟/软件工程过程/" class="nav-link">
  软件工程过程
</a></li><li class="dropdown-item"><!----> <a href="/乱七八糟/WindowsTerminal/" class="nav-link">
  Windows Terminal
</a></li><li class="dropdown-item"><!----> <a href="/乱七八糟/IDEA/" class="nav-link">
  IDEA
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  Guide
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">数据结构与算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">数据结构与算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/数据结构与算法/大话数据结构/" class="nav-link">
  大话数据结构
</a></li><li class="dropdown-item"><!----> <a href="/数据结构与算法/哈学院算法培训/" class="nav-link">
  哈学院算法培训
</a></li><li class="dropdown-item"><!----> <a href="/数据结构与算法/快速幂算法 牛客小白月赛 1-C分元宵/" class="nav-link">
  快速幂算法
</a></li><li class="dropdown-item"><!----> <a href="/数据结构与算法/数据结构_邓俊辉/" class="nav-link">
  数据结构_邓俊辉
</a></li><li class="dropdown-item"><!----> <a href="/数据结构与算法/数据结构_学校/" class="nav-link">
  数据结构(学校）
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/语言/文件读写/" class="nav-link">
  文件读写
</a></li><li class="dropdown-item"><!----> <a href="/语言/哈学院算法培训/" class="nav-link">
  哈学院算法培训
</a></li><li class="dropdown-item"><!----> <a href="/语言/Java/" class="nav-link">
  Java
</a></li><li class="dropdown-item"><!----> <a href="/语言/Javascript/" class="nav-link">
  Javascript
</a></li><li class="dropdown-item"><!----> <a href="/语言/python-北理工/" class="nav-link">
  python
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">乱七八糟</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">乱七八糟</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/乱七八糟/乱七八糟/" class="nav-link">
  乱七八糟
</a></li><li class="dropdown-item"><!----> <a href="/乱七八糟/虚拟机安装凤凰OS/" class="nav-link">
  虚拟机安装凤凰OS
</a></li><li class="dropdown-item"><!----> <a href="/乱七八糟/数据库/" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/乱七八糟/国内访问GitHub/" class="nav-link">
  国内访问GitHub
</a></li><li class="dropdown-item"><!----> <a href="/乱七八糟/Markdown/" class="nav-link">
  Markdown
</a></li><li class="dropdown-item"><!----> <a href="/乱七八糟/软件工程过程/" class="nav-link">
  软件工程过程
</a></li><li class="dropdown-item"><!----> <a href="/乱七八糟/WindowsTerminal/" class="nav-link">
  Windows Terminal
</a></li><li class="dropdown-item"><!----> <a href="/乱七八糟/IDEA/" class="nav-link">
  IDEA
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>数据结构（学校）</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#第一章-绪论" class="sidebar-link">第一章 绪论</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#数据结构的概念" class="sidebar-link">数据结构的概念</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#数据结构的基本概念" class="sidebar-link">数据结构的基本概念</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#算法和算法分析" class="sidebar-link">算法和算法分析</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#时间复杂度比较" class="sidebar-link">时间复杂度比较</a></li></ul></li><li><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#第二章-线性表" class="sidebar-link">第二章 线性表</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#线性表的逻辑结构" class="sidebar-link">线性表的逻辑结构</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#线性表的基本操作" class="sidebar-link">线性表的基本操作</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#线性表的顺序存储结构" class="sidebar-link">线性表的顺序存储结构</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#线性表的链式存储结构" class="sidebar-link">线性表的链式存储结构</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#链表套路" class="sidebar-link">链表套路</a></li></ul></li><li><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#常见题型" class="sidebar-link">常见题型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#题型一-反转链表" class="sidebar-link">题型一：反转链表</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#题型二-合并链表" class="sidebar-link">题型二：合并链表</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#题型三-相交或环形链表" class="sidebar-link">题型三：相交或环形链表</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#题型四-设计题" class="sidebar-link">题型四：设计题</a></li></ul></li><li><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#常见套路" class="sidebar-link">常见套路</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#套路一-反转链表" class="sidebar-link">套路一：反转链表</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#套路二-合并链表" class="sidebar-link">套路二：合并链表</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#套路三-相交或环形链表" class="sidebar-link">套路三：相交或环形链表</a></li></ul></li><li><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#第3章-栈和队列" class="sidebar-link">第3章 栈和队列</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#栈-stack" class="sidebar-link">栈(stack)</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#队列" class="sidebar-link">队列</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#实例研究-表达式求值" class="sidebar-link">实例研究——表达式求值</a></li></ul></li><li><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#第-4-章-串" class="sidebar-link">第 4 章 串</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#串类型的定义" class="sidebar-link">串类型的定义</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#字符串的实现" class="sidebar-link">字符串的实现</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#字符串模式匹配算法" class="sidebar-link">字符串模式匹配算法</a></li></ul></li><li><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#第-5-章-数组和广义表" class="sidebar-link">第 5 章 数组和广义表</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#数组" class="sidebar-link">数组</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#矩阵" class="sidebar-link">矩阵</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#广义表" class="sidebar-link">广义表</a></li></ul></li><li><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#第-6-章-树和二叉树" class="sidebar-link">第 6 章 树和二叉树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#树的基本概念" class="sidebar-link">树的基本概念</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#二叉树" class="sidebar-link">二叉树</a></li></ul></li><li><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#二叉树的性质-2" class="sidebar-link">二叉树的性质</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#二叉树遍历" class="sidebar-link">二叉树遍历</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#线索二叉树" class="sidebar-link">线索二叉树</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#树和森林" class="sidebar-link">树和森林</a></li><li class="sidebar-sub-header"><a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E5%AD%A6%E6%A0%A1.html#哈夫曼树与哈夫曼编码" class="sidebar-link">哈夫曼树与哈夫曼编码</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="数据结构-学校"><a href="#数据结构-学校" class="header-anchor">#</a> 数据结构（学校）</h1> <p>hliu@hrbust.edu.cn</p> <p>wx:vinceblogger</p> <p>E1126</p> <p>数据挖掘与</p> <p>模糊逻辑</p> <h2 id="第一章-绪论"><a href="#第一章-绪论" class="header-anchor">#</a> 第一章 绪论</h2> <h3 id="数据结构的概念"><a href="#数据结构的概念" class="header-anchor">#</a> 数据结构的概念</h3> <p>对于数值计算问题的解决方法，主要是用数学方程建立数学模型</p> <p>非数值计算问题，主要采用数据结构的方法建立数学模型</p> <p>数据结构的研究范畴主要是非数值计算问题的操作对象及其它们之间的关系以及在计算机中的表示和实现。</p> <h3 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="header-anchor">#</a> 数据结构的基本概念</h3> <h4 id="数据"><a href="#数据" class="header-anchor">#</a> 数据</h4> <p>数据是信息的载体，是描述客观事物的数、字符、以及所有能输入到计算机中，被计算机程序识别和处理的符号的集合</p> <ul><li>数值性数据</li> <li>非数值性数据</li></ul> <h4 id="数据元素"><a href="#数据元素" class="header-anchor">#</a> 数据元素</h4> <ul><li>数据的基本单位。在计算机程序中常作为一个整体进行考虑和处理</li> <li>有时一个数据元素可以由若干数据项(Data Item)组成。数据元素又称为元素、结点、记录</li></ul> <h4 id="数据结构"><a href="#数据结构" class="header-anchor">#</a> 数据结构</h4> <p>定义：由某一数据元素的集合及该集合中所有数据元素之间的关系组成</p> <p>记DataStructure= (D, S)</p> <p>其中，D是某一数据元素的有限集合，S是该集合中所有数据元素之间的关系组成的有限集合</p> <h4 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="header-anchor">#</a> <strong>数据的逻辑结构</strong></h4> <ul><li><p>数据的逻辑结构从逻辑关系上描述数据，与数据的存储无关</p></li> <li><p>数据的逻辑结构可以看作是从具体问题抽象出来的数学模型</p></li></ul> <p>数据的逻辑结构可归结为以下四类</p> <ul><li>线性结构
<ul><li>一对一</li> <li>第一个结点无前驱</li> <li>最后一个节点无后继</li></ul></li></ul> <div class="language-mermaid extra-class"><pre class="language-text"><code>graph LR
A(A)--&gt;B(B)--&gt;C(C)--&gt;D(D)--&gt;E(E)
</code></pre></div><ul><li><p>树形结构</p> <ul><li>一对多</li> <li><code>&lt;A,B&gt;</code>有向，<code>(C,D)</code>无向</li></ul></li></ul> <div class="language-mermaid extra-class"><pre class="language-text"><code>graph TD
A(A)
B(B)
C(C)
D(D)
E(E)
F(F)
G(G)
A--&gt;B
A--&gt;C
A--&gt;D
C--&gt;E
C--&gt;F
E--&gt;G
</code></pre></div><ul><li>图状结构
<ul><li>多对多</li></ul></li></ul> <div class="language-mermaid extra-class"><pre class="language-text"><code>graph LR
A(A)
B(B)
C(C)
D(D)
E(E)
A--&gt;B
A--&gt;C
C--&gt;D
D--&gt;B
E--&gt;B
</code></pre></div><ul><li>集合结构</li></ul> <div class="language-mermaid extra-class"><pre class="language-text"><code>graph TD
A(A)
B(B)
C(C)
</code></pre></div><h4 id="数据的存储结构"><a href="#数据的存储结构" class="header-anchor">#</a> 数据的存储结构</h4> <ul><li>数据的存储结构是逻辑结构用计算机语言的实现</li> <li>数据的存储结构依赖于计算机语言
<ul><li>顺序存储结构</li> <li>链式存储结构</li></ul></li></ul> <h5 id="顺序存储"><a href="#顺序存储" class="header-anchor">#</a> 顺序存储</h5> <p>所有元素存放在一片连续的存储单元中，逻辑上相邻的元素存放到计算机内存仍然相邻</p> <h5 id="链式存储"><a href="#链式存储" class="header-anchor">#</a> 链式存储</h5> <p>所有元素存放在可以不连续的存储单元中，但元素之间的关系可以通过地址确定，逻辑上相邻的元素存放到计算机内存后不一定是相邻的</p> <h4 id="抽象数据类型及其实现"><a href="#抽象数据类型及其实现" class="header-anchor">#</a> 抽象数据类型及其实现</h4> <ul><li><p>数据类型
一组性质相同的值的集合, 以及定义于这个值集合上的一组操作的总称</p> <ul><li>构造数据类型由不同成员构成</li> <li>基本数据类型可以看作是计算机中已实现的数据类型</li></ul></li> <li><p>抽象数据类型 ADT: Abstract Data Type)</p> <p>是指一个数学模型以及定义在此数学模型上的一组操作。</p> <ul><li>两个重要特征
<ul><li>抽象性
<ul><li>用ADT描述程序处理的实体时，强调的是其本质的特征、其所能完成的功能以及它和外部用户的接口（即外界使用它的方法）</li></ul></li> <li>封装性
<ul><li>将实体的外部特性和其内部实现细节分离，并且对外部用户隐藏其内部实现细节</li></ul></li></ul></li></ul></li> <li><p>抽象数据类型的表示和实现</p> <ul><li>抽象数据类型需要通过固有数据类型(高级编程语言中已实现的数据类型)来实现，本课程中由类模板或类来实现。</li></ul></li></ul> <h3 id="算法和算法分析"><a href="#算法和算法分析" class="header-anchor">#</a> 算法和算法分析</h3> <h4 id="算法定义"><a href="#算法定义" class="header-anchor">#</a> 算法定义</h4> <p>算法是为了解决某类问题而规定的一个有限长的操作序列</p> <h5 id="算法应具有的性质"><a href="#算法应具有的性质" class="header-anchor">#</a> 算法应具有的性质</h5> <ul><li>正确性</li> <li>具体性</li> <li>确定性</li> <li>有限性</li> <li>可读性</li> <li>健壮性</li></ul> <ol><li><p>正确性</p> <p>正确性指必须完成所期望的功能，对算法是否“正确”的理解可以有如下四个层次：</p> <ul><li>程序中不含任何语法错误。</li> <li>程序对于几组输入数据能够得出满足要求的结果。</li> <li>程序对于精心选择的、典型的、苛刻的并带有刁难性的几组输入数据能够得出满足要求的结果。</li> <li>程序对于一切输入数据都能得出满足要求的结果。</li></ul></li> <li><p>具体性</p> <p>一个算法必须由一系列具体操作组成，这时的“具体”指的所有操作都必须经过已实现的基本操作有限次来实现，并且所有操作都是可读的、可执行的，每一操作必须在有限时间内完成。</p></li> <li><p>确定性</p> <p>算法中的所有操作都必须有确切的含义，不能产生歧义，算法的执行者或阅读者都能明确其含义及如何执行。</p></li> <li><p>有限性
对于任意一组合法输入值，在执行有限步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成</p></li> <li><p>可读性</p> <p>算法应具备良好的可读性，这样的算法有利于算法的查错及对算法的理解，一般算法的逻辑必须清楚、结构简单，所有标识符必须具有实际含义，能见名知义。</p></li> <li><p>健壮性</p> <p>健壮性指当输入数据非法时，算法能作适当的处理并作出反应，而不应死机或输出异常结果</p></li></ol> <h5 id="算法描述方法"><a href="#算法描述方法" class="header-anchor">#</a> 算法描述方法</h5> <ul><li><p>用自然语言描述算法
用我们日常生活中的自然语言（可以是中文形式，也可以是英文形式）也可以描述算法</p></li> <li><p>用流程图描述算法
一个算法可以用流程图的方式来描述，输入输出、判断、处理分别用不同的框图表示，用箭头表示流程的流向。这是一种描述算法的较好方法，目前在一些高级语言程序设计中仍然采用。也有其他的图形辅助工具、</p></li> <li><p>用其它方式描述算法</p> <p>我们还可以用数学语言或约定的符号语言来描述算法</p></li> <li><p>用程序设计语言描述算法</p> <p>在本课中，我们将采用C++来描述算法,所有算法的描述都用C++中的函数模板或函数形式来描述</p></li></ul> <h5 id="算法和程序的关系"><a href="#算法和程序的关系" class="header-anchor">#</a> 算法和程序的关系</h5> <ul><li>算法着重体现思路和方法，程序着重体现计算机的实现</li> <li>程序不一定满足有穷性（死循环），另外，程序中的指令必须是机器可执行的，算法中的指令无此限制</li> <li>一个算法若用计算机语言来书写，它就是一个程序</li></ul> <h5 id="算法评价标准"><a href="#算法评价标准" class="header-anchor">#</a> 算法评价标准</h5> <ul><li>时间特性(时间复杂度T(n) )</li> <li>空间特性(空间复杂度S(n) )</li></ul> <h4 id="算法描述方法-2"><a href="#算法描述方法-2" class="header-anchor">#</a> 算法描述方法</h4> <ul><li><p>用自然语言描述算法</p> <p>用我们日常生活中的自然语言（可以是中文形式，也可以是英文形式）也可以描述算法</p></li> <li><p>用流程图描述算法</p> <p>一个算法可以用流程图的方式来描述，输入输出、判断、处理分别用不同的框图表示，用箭头表示流程的流向。这是一种描述算法的较好方法，目前在一些高级语言程序设计中仍然采用。也有其他的图形辅助工具</p></li> <li><p>用其它方式描述算法</p> <p>我们还可以用数学语言或约定的符号语言来描述算法</p></li> <li><p>用程序设计语言描述算法</p> <p>在本课中，我们将采用C++来描述算法,所有算法的描述都用C++中的函数模板或函数形式来描述</p></li></ul> <p>为表示各种状态信息，定义枚举类型StatusCode供使用，具体声明如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 自定义类型</span>
<span class="token keyword">enum</span> <span class="token class-name">StatusCode</span> <span class="token punctuation">{</span>
    SUCCESS<span class="token punctuation">,</span> FAIL<span class="token punctuation">,</span> UNDER_FLOW<span class="token punctuation">,</span> 				
    OVER_FLOW<span class="token punctuation">,</span>RANGE_ERROR<span class="token punctuation">,</span> DUPLICATE_ERROR<span class="token punctuation">,</span> 
    NOT_PRESENT<span class="token punctuation">,</span> ENTRY_INSERTED<span class="token punctuation">,</span> ENTRY_FOUND<span class="token punctuation">,</span> 
    VISITED<span class="token punctuation">,</span> UNVISITED
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="算法和程序的关系-2"><a href="#算法和程序的关系-2" class="header-anchor">#</a> <strong>算法和程序的关系</strong></h4> <ul><li>算法着重体现思路和方法，程序着重体现计算机的实现</li> <li>程序不一定满足有穷性（死循环），另外，程序中的指令必须是机器可执行的，算法中的指令无此限制</li> <li>一个算法若用计算机语言来书写，它就是一个程序</li></ul> <h4 id="算法评价标准-2"><a href="#算法评价标准-2" class="header-anchor">#</a> 算法评价标准</h4> <ul><li>时间特性(时间复杂度T(n) )</li> <li>空间特性(空间复杂度S(n) )</li></ul> <h3 id="时间复杂度比较"><a href="#时间复杂度比较" class="header-anchor">#</a> 时间复杂度比较</h3> <p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n<sup>2</sup>)&lt;O(n<sup>3</sup>)&lt;O(2<sup>n</sup>)&lt;O(n!)&lt;O(n<sup>n</sup>)</p> <h2 id="第二章-线性表"><a href="#第二章-线性表" class="header-anchor">#</a> 第二章 线性表</h2> <h3 id="线性表的逻辑结构"><a href="#线性表的逻辑结构" class="header-anchor">#</a> 线性表的逻辑结构</h3> <h4 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="header-anchor">#</a> 线性表的定义和特点</h4> <h5 id="线性表的定义"><a href="#线性表的定义" class="header-anchor">#</a> 线性表的定义</h5> <p>n(≥0)个数据元素的有限序列，记作：</p> <p>​			(a<sub>1</sub>,a<sub>2</sub>,...,a<sub>n</sub>)</p> <p>ai是线性表中的数据元素，n是线性表长度，期中a<sub>i</sub>称为a<sub>i+1</sub>的直接前驱，简称为前驱，a<sub>i+1</sub>称为a<sub>i</sub>的直接后继，简称为后继。</p> <h5 id="线性表的特点"><a href="#线性表的特点" class="header-anchor">#</a> 线性表的特点</h5> <ul><li><p>除第一个元素外，其他每一个元素有且仅有一个直接前驱</p></li> <li><p>除最后一个元素外，其他每一个元素有且仅有一个直接后继</p> <div class="language-mermaid extra-class"><pre class="language-text"><code>graph LR
1--&gt;2--&gt;3--&gt;4--&gt;5
</code></pre></div></li></ul> <h3 id="线性表的基本操作"><a href="#线性表的基本操作" class="header-anchor">#</a> 线性表的基本操作</h3> <ol><li><p>int Length() const
初始条件：线性表已存在</p> <p>操作结果：返回线性表的元素个数</p></li> <li><p>bool Empty() const
初始条件：线性表已存在</p> <p>操作结果：如果线性表为空，则返回true，否则返回false</p></li> <li><p>void Clear()</p> <p>初始条件：线性表已存在。</p> <p>操作结果：清空线性表。</p></li> <li><p>void Traverse(void (*visit)(const ElemType &amp;)) const</p> <p>初始条件：线性表已存在</p> <p>操作结果：依次对线性表的每个元素调用函数(*visit)。遍历</p></li> <li><p>bool GetElem(int position,ElemType &amp;e)const</p> <p>初始条件：线性表已存在，1≤position≤Length() 。</p> <p>操作结果：用e返回第posiiton个元素的值。</p></li> <li><p>bool SetElem(int position,const ElemType &amp;e)</p> <p>初始条件：线性表已存在，1≤position≤Length()。</p> <p>操作结果：将线性表的position个位置的元素赋值为e。</p></li> <li><p>bool Delete(int position,ElemType &amp;e)</p> <p>初始条件：线性表已存在，1≤position≤Length()。</p> <p>操作结果：删除线性表的第position个位置的元素，并用e返回其值，长度减1。</p></li> <li><p>bool Insert(int position,const ElemType &amp;e)</p> <p>初始条件：线性表已存在，1≤position≤Length()+1。</p> <p>操作结果：在线性表的第position个位置钱插入e，长度加1。</p></li></ol> <h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="header-anchor">#</a> 线性表的顺序存储结构</h3> <h4 id="顺序表的定义和特点"><a href="#顺序表的定义和特点" class="header-anchor">#</a> 顺序表的定义和特点</h4> <ul><li><p>定义：将线性表中的元素相继存放在一个连续的存储空间中。</p></li> <li><p>特点：可利用一维数组描述存储结构，采用线性表的顺序存储方式</p> <ol><li><p>线性表的顺序存储结构用一组地址连续的存储单元一次存储线性表的元素</p></li> <li><p>线性表的顺序存储结构用元素在存储器中的“物理位置相邻”表示线性表中数据元素之间的逻辑关系，设LOC(ai)表示数据元素ai的存储位置，L为每个元素占用的存储单元个数，则有如下关系：</p> <center>LOC(a<sub>i+1</sub>)=LOC(a<sub>i</sub>)+L</center> <center>LOC(a<sub>i</sub>)=LOC(a<sub>i</sub>)+(i-1)*L</center></li> <li><p>线性表的顺序存储结构可直接随机存取任一个数据元素，所以线性表的顺序存储结构是一种随机存取的结构</p></li> <li><p>在进行插入或删除操作时需移动大量的数据元素</p></li></ol> <p><img src="/assets/img/ds_school/img/image-20201012135641786.png" alt="image-20201012135641786"></p></li></ul> <h4 id="顺序表的类模板的定义"><a href="#顺序表的类模板的定义" class="header-anchor">#</a> 顺序表的类模板的定义</h4> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 顺序表类模板</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SqList</span>
<span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token comment">// 顺序表实现的数据成员:</span>
	<span class="token keyword">int</span> count<span class="token punctuation">;</span> 				<span class="token comment">// 元素个数</span>
	<span class="token keyword">int</span> maxSize<span class="token punctuation">;</span> 			<span class="token comment">// 顺序表最大元素个数</span>
	ElemType <span class="token operator">*</span>elems<span class="token punctuation">;</span> 		<span class="token comment">// 元素存储空间</span>
    <span class="token comment">// 辅助函数模板</span>
    <span class="token keyword">bool</span> <span class="token function">Full</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 		<span class="token comment">// 判断线性表是否已满</span>
    <span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 初始化线性表</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 抽象数据类型方法声明及重载编译系统默认方法声明:</span>
    <span class="token function">SqList</span><span class="token punctuation">(</span><span class="token keyword">int</span> size <span class="token operator">=</span> DEFAULT_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 构造函数模板</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">SqList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">// 析构函数模板</span>
    <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 			<span class="token comment">// 求线性表长度</span>
    <span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 			<span class="token comment">// 判断线性表是否为空</span>
    <span class="token keyword">void</span> <span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 					<span class="token comment">// 将线性表清空</span>
    <span class="token keyword">void</span> <span class="token function">Traverse</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 	<span class="token comment">// 遍历线性表</span>
    <span class="token keyword">bool</span> <span class="token function">GetElem</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>			<span class="token comment">// 求指定位置的元素</span>
    <span class="token keyword">bool</span> <span class="token function">SetElem</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> <span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 设置指定位置的元素值</span>
    <span class="token keyword">bool</span> <span class="token function">Delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 删除元素</span>
    <span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> <span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 插入元素</span>
    <span class="token function">SqList</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqList<span class="token operator">&lt;</span>elemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 复制构造函数模板</span>
    SqList<span class="token operator">&lt;</span>elemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqList<span class="token operator">&lt;</span>elemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 重载赋值运算符</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="顺序表辅助函数模板的实现"><a href="#顺序表辅助函数模板的实现" class="header-anchor">#</a> 顺序表辅助函数模板的实现</h4> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token class-name">SqList</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Full</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token comment">// 操作结果：如线性表已满，则返回true，否则返回false</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> count <span class="token operator">==</span> maxSize<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">SqList</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Init</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：初始化线性表为最大元素个数为size的空线性表</span>
<span class="token punctuation">{</span>
    maxSize <span class="token operator">=</span> size<span class="token punctuation">;</span> 					<span class="token comment">// 最大元素个数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>elems <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>elems<span class="token punctuation">;</span>	<span class="token comment">// 释放存储空间</span>
    elems <span class="token operator">=</span> <span class="token keyword">new</span> ElemType<span class="token punctuation">[</span>maxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">// 分配存储空间</span>
    count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>							<span class="token comment">// 空线性表元素个数为0</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="顺序表部分操作的实现"><a href="#顺序表部分操作的实现" class="header-anchor">#</a> 顺序表部分操作的实现</h4> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token class-name">SqList</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">SqList</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：构造一个最大元素个数为size的空顺序表</span>
<span class="token punctuation">{</span>
    elems <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> 	<span class="token comment">// 未分配存储空间前,elems为空</span>
    <span class="token function">Init</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 初始化线性表</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
SqList<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token operator">~</span><span class="token function">SqList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 操作结果：销毁线性表</span>
<span class="token punctuation">{</span>
	<span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>elems<span class="token punctuation">;</span> <span class="token comment">// 释放存储空间</span>
<span class="token punctuation">}</span>
</code></pre></div><ol><li><p>表项的插入</p> <p><img src="/assets/img/ds_school/img/image-20201012135721185.png" alt="image-20201012135721185"></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token class-name">SqList</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> <span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：在线性表的第position个位置前插入元</span>
<span class="token comment">// 素e, position的取值范围为</span>
<span class="token comment">// 1≤position≤Length()+1, 如线性表已满,则</span>
<span class="token comment">// 返回false, 如position合法, 则返回true, 否</span>
<span class="token comment">// 则返回false</span>
<span class="token punctuation">{</span>
    ElemType tmp<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> maxSize<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>	<span class="token comment">// 线性表已满</span>
   		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>position<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">||</span> position<span class="token operator">&gt;</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> 	<span class="token comment">// position范围错</span>
    	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span> 	<span class="token comment">// 成功</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 插入后元素个数将自增1</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> pos<span class="token operator">&gt;=</span>position<span class="token punctuation">;</span>pos<span class="token operator">--</span><span class="token punctuation">)</span>
    	<span class="token punctuation">{</span> <span class="token comment">// 插入位置之后的元素右移</span>
            <span class="token function">GetElem</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">SetElem</span><span class="token punctuation">(</span>pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  		<span class="token punctuation">}</span>
        <span class="token function">SetElem</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 将e赋值到position位置处</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 			<span class="token comment">// 插入成功</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>表项的删除</p> <p><img src="/assets/img/ds_school/img/image-20201012135739865.png" alt="image-20201012135739865"></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token class-name">SqList</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：删除线性表的第position个位置的元素,并前用e返回其值,position的的取值范围为1≤position≤Length(),position合法时函数返回true,否则返回false</span>
<span class="token punctuation">{</span>
    ElemType tmp<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> position <span class="token operator">&gt;</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>	<span class="token comment">// position范围错</span>
    	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span> 	<span class="token comment">// position合法</span>
   		<span class="token function">GetElem</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 用e返回被删除元素的值</span>
    	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> pos <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> pos <span class="token operator">&lt;=</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pos<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span> 	<span class="token comment">// 被删除元素之后的元素依次左移</span>
            <span class="token function">GetElem</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">SetElem</span><span class="token punctuation">(</span>pos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span> 		<span class="token comment">// 删除后元素个数将自减1</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol> <h4 id="顺序表的应用-集合的-差-运算"><a href="#顺序表的应用-集合的-差-运算" class="header-anchor">#</a> 顺序表的应用：集合的“差” 运算</h4> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 文件路径名:s2_1\alg.h</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">Difference</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqList<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>la<span class="token punctuation">,</span> <span class="token keyword">const</span> SqList<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>lb<span class="token punctuation">,</span> SqList<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>lc<span class="token punctuation">)</span>
<span class="token comment">// 操作结果: 用lc返回la和lb表示的集合的差集</span>
<span class="token comment">// 方法: 在la中取出元素,在lb中进行查找,如果未在lb中出现了,将其插入到lc</span>
<span class="token punctuation">{</span>
    ElemType aElem<span class="token punctuation">,</span> bElem<span class="token punctuation">;</span>
    lc<span class="token punctuation">.</span><span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 		<span class="token comment">// 清空lc	</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> aPos <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> aPos <span class="token operator">&lt;=</span> la<span class="token punctuation">.</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> aPos<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        la<span class="token punctuation">.</span><span class="token function">GetElem</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> aElem<span class="token punctuation">)</span><span class="token punctuation">;</span> 		<span class="token comment">// 取出la的一个元素aElem</span>
        <span class="token keyword">bool</span> isExist <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>			<span class="token comment">// 表示aElem是否在lb中出现</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> bPos <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> bPos <span class="token operator">&lt;=</span> lb<span class="token punctuation">.</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> bPos<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            lb<span class="token punctuation">.</span><span class="token function">GetElem</span><span class="token punctuation">(</span>bPos<span class="token punctuation">,</span> bElem<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 取出lb的一个元素bElem</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>aElem <span class="token operator">==</span> bElem<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                isExist <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>			<span class="token comment">// aElem同时在 la和lb中出现,置isExist为true</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span> 					<span class="token comment">// 退出内层循环</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isExist<span class="token punctuation">)</span>
        <span class="token punctuation">{</span> 	<span class="token comment">// aElem在la中出现,而未在lb中未出现,将其插入到lc中</span>
       		lc<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>lc<span class="token punctuation">.</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> aElem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="header-anchor">#</a> 线性表的链式存储结构</h3> <h4 id="一、单链表-simple-linked-list"><a href="#一、单链表-simple-linked-list" class="header-anchor">#</a> 一、单链表 (Simple Linked List)</h4> <h5 id="单链表的概念"><a href="#单链表的概念" class="header-anchor">#</a> 单链表的概念</h5> <p>用一组地址任意的存储单元存放线性表中的数据元素。</p> <p>以data(元素的值) + next(后继) = 结点(表示数据元素)</p> <p>以“结点的序列”表示线性表称作单链表</p> <p><img src="/assets/img/ds_school/img/image-20201012135817049.png" alt="image-20201012135817049"></p> <p>以线性表中第一个数据元素a<sub>1</sub>的存储地址作为线性表的地址，称作线性表的头指针。</p> <p>有时为了操作方便，在第一个结点之前 虚加一个“头结点”，这时指向头结点 的指针称为链表的头指针。，。</p> <h5 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h5> <ul><li>数据元素之间的逻辑关系由结点中的后继指针表示</li> <li>每个数据元素的存储位置由其直接前驱的后继指针表示</li> <li>线性表的链式存储结构是非随机存取的存储结构</li> <li>线性表的链式存储结构中的尾结点的直接后继为空（即此结点的后继指针为空）</li></ul> <h5 id="单链表的相关类模板"><a href="#单链表的相关类模板" class="header-anchor">#</a> 单链表的相关类模板</h5> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 结点类模板</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Node</span>
<span class="token punctuation">{</span>
<span class="token comment">// 数据成员:</span>
    ElemType data<span class="token punctuation">;</span>			<span class="token comment">// 数据域</span>
    Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> 	<span class="token comment">// 指针域</span>
<span class="token comment">// 构造函数模板:</span>
    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">// 无参数的构造函数模板</span>
    <span class="token function">Node</span><span class="token punctuation">(</span>ElemType item<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>link <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 已知数据域和指针域建立结构</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 简单线性链表类模板</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SimpleLinkList</span>
<span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
<span class="token comment">// 链表实现的数据成员:</span>
	Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>head<span class="token punctuation">;</span> <span class="token comment">// 头结点指针</span>
<span class="token comment">// 辅助函数模板:</span>
	Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token function">GetElemPtr</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>	<span class="token comment">// 返回指向第position个结点的指针</span>
	<span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化线性表</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment">// 抽象数据类型方法声明及重载编译系统默认方法声明:</span>
	<span class="token function">SimpleLinkList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>								<span class="token comment">// 无参数构造函数模板</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">SimpleLinkList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>						<span class="token comment">// 析构函数模板</span>
    <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 							<span class="token comment">// 求线性表长度</span>
    <span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>								<span class="token comment">// 判断线性表是否为空</span>
    <span class="token keyword">void</span> <span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 									<span class="token comment">// 将线性表清空</span>
    <span class="token keyword">void</span> <span class="token function">Traverse</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">// 遍历线性表</span>
    <span class="token keyword">bool</span> <span class="token function">GetElem</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span> 	<span class="token comment">// 求指定位置的元素</span>
    <span class="token keyword">bool</span> <span class="token function">SetElem</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> <span class="token keyword">const</span> ElemType<span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 设置指定位置的元素值</span>
    <span class="token keyword">bool</span> <span class="token function">Delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 删除元素</span>
    <span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> <span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 插入元素</span>
	<span class="token function">SimpleLinkList</span><span class="token punctuation">(</span><span class="token keyword">const</span> SimpleLinkList<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 复制构造函数模板</span>
	SimpleLinkList<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> SimpleLinkList<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 重载赋值运算符</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="单链表中的插入与删除"><a href="#单链表中的插入与删除" class="header-anchor">#</a> 单链表中的插入与删除</h5> <h6 id="插入"><a href="#插入" class="header-anchor">#</a> 插入</h6> <p><img src="/assets/img/ds_school/img/image-20201012135839282.png" alt="image-20201012135839282"></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>newPtr <span class="token operator">=</span> <span class="token keyword">new</span> Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> tmpPtr<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
tmpPtr<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newPtr<span class="token punctuation">;</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token class-name">LinkList</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> <span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：在线性表的第position个位置前插入元素e,</span>
<span class="token comment">// position的取值范围为1≤position≤Length()+1,</span>
<span class="token comment">// position合法时返回true, 否则返回false</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> position <span class="token operator">&gt;</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token comment">// position范围错</span>
    	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 位置不合法</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span> <span class="token comment">// position合法</span>
        Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>tmpPtr<span class="token punctuation">;</span>
        tmpPtr <span class="token operator">=</span> <span class="token function">GetElemPtr</span><span class="token punctuation">(</span>position <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 取出指向第position-1个结点的指针</span>
        Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>newPtr<span class="token punctuation">;</span>
        newPtr <span class="token operator">=</span> <span class="token keyword">new</span> Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> tmpPtr<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 生成新结点</span>
        tmpPtr<span class="token operator">-&gt;</span>next <span class="token operator">=</span> newPtr<span class="token punctuation">;</span>				<span class="token comment">// 将tmpPtr插入到链表中</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h6 id="删除"><a href="#删除" class="header-anchor">#</a> 删除</h6> <p><img src="/assets/img/ds_school/img/image-20201012135905609.png" alt="image-20201012135905609"></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>nextPtr <span class="token operator">=</span> tmpPtr<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> 		<span class="token comment">// nextPtr为tmpPtr的后继</span>
tmpPtr<span class="token operator">-&gt;</span>next <span class="token operator">=</span> nextPtr<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>	<span class="token comment">// 删除结点</span>
<span class="token keyword">delete</span> nextPtr<span class="token punctuation">;</span> 				<span class="token comment">// 释放被删结点</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token class-name">LinkList</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：删除线性表的第position个位置的元素, 并用</span>
<span class="token comment">// e返回其值, position的取值范围为</span>
<span class="token comment">// 1≤position≤Length(), position合法时返回true,否</span>
<span class="token comment">// 则函数返回false</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> position <span class="token operator">&gt;</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token comment">// position范围错</span>
   		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span> 	<span class="token comment">// position合法</span>
        Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>tmpPtr<span class="token punctuation">;</span>
        tmpPtr <span class="token operator">=</span> <span class="token function">GetElemPtr</span><span class="token punctuation">(</span>position <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 取出指向第position-1个结点的指针</span>
        Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>nextPtr <span class="token operator">=</span> tmpPtr<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>	<span class="token comment">// nextPtr为tmpPtr的后继</span>
        tmpPtr<span class="token operator">-&gt;</span>next <span class="token operator">=</span> nextPtr<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>			<span class="token comment">// 删除结点</span>
        e <span class="token operator">=</span> nextPtr<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>						<span class="token comment">// 用e返回被删结点元素值</span>
        <span class="token keyword">delete</span> nextPtr<span class="token punctuation">;</span> 						<span class="token comment">// 释放被删结点</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="二、循环链表-circular-list"><a href="#二、循环链表-circular-list" class="header-anchor">#</a> 二、循环链表 (Circular List)</h4> <h5 id="循环链表的概念"><a href="#循环链表的概念" class="header-anchor">#</a> 循环链表的概念</h5> <ul><li>循环链表是单链表的变形。</li> <li>循环链表最后一个结点的next指针不为 NULL， 而是指向了表的前端。</li> <li>为简化操作，在循环链表中往往加入表头结点。</li> <li>循环链表的特点是：只要知道表中某一结点的地址，就可搜寻到所有其他结点的地址。</li></ul> <h5 id="循环链表示例"><a href="#循环链表示例" class="header-anchor">#</a> 循环链表示例</h5> <h5 id="循环链表的相关类模板"><a href="#循环链表的相关类模板" class="header-anchor">#</a> 循环链表的相关类模板</h5> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 简单循环链表类模板</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SimpleCircLinkList</span>
<span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
<span class="token comment">// 循环链表实现的数据成员:</span>
	Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>head<span class="token punctuation">;</span> <span class="token comment">// 头结点指针</span>
<span class="token comment">// 辅助函数模板:</span>
	Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token function">GetElemPtr</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>	<span class="token comment">// 返回指向第position个结点的指针</span>
	<span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化线性表</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment">// 抽象数据类型方法声明及重载编译系统默认方法声明:</span>
    <span class="token function">SimpleCircLinkList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 无参数的构造函数模板</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">SimpleCircLinkList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 析构函数模板</span>
    <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 			<span class="token comment">// 求线性表长度</span>
    <span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 			<span class="token comment">// 判断线性表是否为空</span>
    <span class="token keyword">void</span> <span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 					<span class="token comment">// 将线性表清空</span>
    <span class="token keyword">void</span> <span class="token function">Traverse</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 	<span class="token comment">// 遍历线性表</span>
    <span class="token keyword">bool</span> <span class="token function">GetElem</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 			<span class="token comment">// 求指定位置的元素</span>
    <span class="token keyword">bool</span> <span class="token function">SetElem</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> <span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 设置指定位置的元素值</span>
    <span class="token keyword">bool</span> <span class="token function">Delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">// 删除元素</span>
    <span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> <span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 插入元素</span>
    <span class="token function">SimpleCircLinkList</span><span class="token punctuation">(</span><span class="token keyword">const</span> SimpleCircLinkList<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>						<span class="token comment">// 复制构造函数模板</span>
    SimpleCircLinkList<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span>constSimpleCircLinkList<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 重载赋值运算符</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="循环链表的应用-用循环链-表求解约瑟夫问题"><a href="#循环链表的应用-用循环链-表求解约瑟夫问题" class="header-anchor">#</a> 循环链表的应用——用循环链 表求解约瑟夫问题</h5> <div class="language-txt extra-class"><pre class="language-text"><code>约瑟夫问题的提法
n 个人围成一个圆圈，首先第1个人从1开始一个人一个人顺时针报数, 报到第m个人，令其出列。然后再从下一个人开始，从1顺时针报数，报到第m个人，再令其出列，…，如此下去, 直到圆圈中只剩一个人为止。此人即为优胜者。
例如 n = 8 m = 3
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 文件路径名:s2_5\alg.h</span>
<span class="token keyword">void</span> <span class="token function">Josephus</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span>
<span class="token comment">// 操作结果:n个人围成一个圆圈，首先第1个人从1开始一</span>
<span class="token comment">// 个人一个人顺时针报数,报到第m个人，令其出列。</span>
<span class="token comment">// 然后再从下一个人开始，从1顺时针报数报到第m</span>
<span class="token comment">// 个人，再令其出列，…，如此下去, 直到圆圈中只</span>
<span class="token comment">// 剩一个人为止。此人即为优胜者</span>
<span class="token punctuation">{</span>
    SimpleCircLinkList<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> la<span class="token punctuation">;</span> <span class="token comment">// 定义空循环链表</span>
    <span class="token keyword">int</span> position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 报数到的人在链表中序号</span>
    <span class="token keyword">int</span> out<span class="token punctuation">,</span> winer<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> la<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 建立数据域为1,2,..,n的循环链表</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;出列者:&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token comment">// 循环n-1次，让n-1个个出列</span>
    	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span> <span class="token comment">// 从1报数到m</span>
            position<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&gt;</span> la<span class="token punctuation">.</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            	position <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    	<span class="token punctuation">}</span>
    	la<span class="token punctuation">.</span><span class="token function">Delete</span><span class="token punctuation">(</span>position<span class="token operator">--</span><span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 报数到m的人出列</span>
   		cout <span class="token operator">&lt;&lt;</span> out <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    la<span class="token punctuation">.</span><span class="token function">GetElem</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> winer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 剩下的一个人为优胜者</span>
    cout <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;优胜者:&quot;</span> <span class="token operator">&lt;&lt;</span> winer <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="三、双向链表-doubly-linked-list"><a href="#三、双向链表-doubly-linked-list" class="header-anchor">#</a> 三、双向链表 (Doubly Linked List)</h4> <h5 id="双向链表的概念"><a href="#双向链表的概念" class="header-anchor">#</a> 双向链表的概念</h5> <ul><li>双向链表是指在前驱和后继方向都能游历 (遍历)的线性链表。</li> <li>双向链表每个结点结构：</li> <li>前驱方向 ➔后继方向</li> <li>双向链表通常采用带表头结点的循环链表形式。</li></ul> <h5 id="双向循环链表示例"><a href="#双向循环链表示例" class="header-anchor">#</a> 双向循环链表示例</h5> <p><img src="/assets/img/ds_school/img/image-20201012135942495.png" alt="image-20201012135942495"></p> <h4 id="在链表结构中保存当前位置和元素个数"><a href="#在链表结构中保存当前位置和元素个数" class="header-anchor">#</a> 在链表结构中保存当前位置和元素个数</h4> <ul><li>前面讲解了线性表的链式存储结构的实现处理简单</li> <li>但许多应用程序可能要几次引用同一个数据元素，对于这类应用程序，前面的链表实现效率低下</li> <li>最好在链表结构中保存当前位置和元素个数。</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 线性链表类模板</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">LinkList</span>
<span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
<span class="token comment">// 链表实现的数据成员:</span>
    Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>head<span class="token punctuation">;</span> 				<span class="token comment">// 头结点指针</span>
    <span class="token keyword">mutable</span> <span class="token keyword">int</span> curPosition<span class="token punctuation">;</span> 			<span class="token comment">// 当前位置的序号</span>
    <span class="token keyword">mutable</span> Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span> curPtr<span class="token punctuation">;</span>	<span class="token comment">// 指向当前位置的指针</span>
	<span class="token keyword">int</span> count<span class="token punctuation">;</span> 							<span class="token comment">// 元素个数</span>
<span class="token comment">// 辅助函数模板:</span>
	Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token function">GetElemPtr</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">// 返回指向第position个结点的指针</span>
	<span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化线性表</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment">// 抽象数据类型方法声明及重载编译系统默认方法声明:</span>
    <span class="token function">LinkList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">// 无参数的构造函数模板</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">LinkList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 		<span class="token comment">// 析构函数模板</span>
    <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 		<span class="token comment">// 求线性表长度</span>
    <span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 		<span class="token comment">// 判断线性表是否为空</span>
    <span class="token keyword">void</span> <span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">// 将线性表清空</span>
    <span class="token keyword">void</span> <span class="token function">Traverse</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span> <span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 	<span class="token comment">// 遍历线性表</span>
    <span class="token keyword">bool</span> <span class="token function">GetElem</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 			<span class="token comment">// 求指定位置的元素</span>
    <span class="token keyword">bool</span> <span class="token function">SetElem</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> <span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>  		<span class="token comment">// 设置指定位置的元素值</span>
    <span class="token keyword">bool</span> <span class="token function">Delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">// 删除元素</span>
    <span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">,</span> <span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 插入元素</span>
    <span class="token function">LinkList</span><span class="token punctuation">(</span><span class="token keyword">const</span> LinkList<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 复制构造函数模板</span>
    LinkList<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> LinkList<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 重载赋值运算符</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="实例研究-一元多项式的表示"><a href="#实例研究-一元多项式的表示" class="header-anchor">#</a> 实例研究—— 一元多项式的表示</h4> <p>一元多项式</p> <p>p<sub>n</sub>(x) = p<sub>0</sub> + p<sub>1</sub>x + p<sub>2</sub>x<sup>2</sup> + ... + p<sub>n</sub>x<sup>n</sup></p> <p>在计算机中，可以用一个线性表来表示:</p> <p>P = (p<sub>0</sub> , p<sub>1</sub> , …，p<sub>n</sub> )</p> <p>但是对于形如 S(x) = 1 + 3x<sup>10000</sup> – 2x<sup>20000</sup> 的多项式，上述表示方法是否合适？</p> <p>一般情况下的一元稀疏多项式可写成</p> <p>P<sub>n</sub> (x) = p<sub>1</sub>x<sup>e1</sup> + p<sub>2</sub>x<sup>e2</sup> + ┄ + p<sub>m</sub>x<sup>em</sup></p> <p>其中：p<sub>i</sub> 是指数为e<sub>i</sub> 的项的非零系数， 0≤ e<sub>1</sub> &lt; e<sub>2</sub>&lt; ┄ &lt; e<sub>m</sub> = n</p> <p>可以下列线性表表示：</p> <p>（（p<sub>1</sub> , e<sub>1</sub>）, (p<sub>2</sub> , e<sub>2</sub> ), ┄, (p<sub>m</sub>,e<sub>m</sub>) ）</p> <p>例如：</p> <p>P<sub>999</sub>(x) = 7x<sup>3</sup> - 2x<sup>12</sup> - 8x<sup>999</sup></p> <p>可用线性表</p> <p>( (7, 3), (-2, 12), (-8, 999) )</p> <p>表示</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 多项式项类</span>
<span class="token keyword">struct</span> <span class="token class-name">PolyItem</span>
<span class="token punctuation">{</span>
<span class="token comment">// 数据成员:</span>
    <span class="token keyword">double</span> coef<span class="token punctuation">;</span> 	<span class="token comment">// 系数</span>
    <span class="token keyword">int</span> expn<span class="token punctuation">;</span>		<span class="token comment">// 指数</span>
<span class="token comment">// 构造函数:</span>
    <span class="token function">PolyItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> 	<span class="token comment">// 无数据的构造函数</span>
    <span class="token function">PolyItem</span><span class="token punctuation">(</span><span class="token keyword">double</span> cf<span class="token punctuation">,</span> <span class="token keyword">int</span> en<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 已知系数域和指数域建立结构</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 多项式类</span>
<span class="token keyword">class</span> <span class="token class-name">Polynomial</span>
<span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
<span class="token comment">// 多项式实现的数据成员:</span>
	LinkList<span class="token operator">&lt;</span>PolyItem<span class="token operator">&gt;</span> polyList<span class="token punctuation">;</span>	<span class="token comment">// 多项式组成的线性表</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 抽象数据类型方法声明:</span>
    <span class="token function">Polynomial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 		<span class="token comment">// 无参构造函数</span>
    <span class="token operator">~</span><span class="token function">Polynomial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 		<span class="token comment">// 析构函数</span>
    <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 	<span class="token comment">// 求多项式的项数</span>
    <span class="token keyword">bool</span> <span class="token function">IsZero</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 	<span class="token comment">// 判断多项式是否为0</span>
    <span class="token keyword">void</span> <span class="token function">SetZero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 		<span class="token comment">// 将多项式置为0</span>
    <span class="token keyword">void</span> <span class="token function">Display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 		<span class="token comment">// 显示多项式</span>
    <span class="token keyword">void</span> <span class="token function">InsItem</span><span class="token punctuation">(</span> <span class="token keyword">const</span> PolyItem <span class="token operator">&amp;</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 插入一项</span>
    Polynomial <span class="token keyword">operator</span> <span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Polynomial <span class="token operator">&amp;</span>p<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 	<span class="token comment">// 加法运算符重载</span>
    Polynomial <span class="token keyword">operator</span> <span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">const</span> Polynomial <span class="token operator">&amp;</span>p<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 	<span class="token comment">// 减法运算符重载</span>
    Polynomial <span class="token keyword">operator</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Polynomial <span class="token operator">&amp;</span>p<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> 	<span class="token comment">// 乘法运算符重载</span>
    <span class="token function">Polynomial</span><span class="token punctuation">(</span><span class="token keyword">const</span> Polynomial <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">// 复制构造函数</span>
    <span class="token function">Polynomial</span><span class="token punctuation">(</span><span class="token keyword">const</span> LinkList<span class="token operator">&lt;</span>PolyItem<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copyLinkList<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 由多项式组成的线性表构造多项式</span>
    Polynomial <span class="token operator">&amp;</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Polynomial <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 重载赋值运算符</span>
    Polynomial <span class="token operator">&amp;</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> LinkList<span class="token operator">&lt;</span>PolyItem<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copyLinkList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重载赋值运算符</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="链表套路"><a href="#链表套路" class="header-anchor">#</a> 链表套路</h3> <h2 id="常见题型"><a href="#常见题型" class="header-anchor">#</a> 常见题型</h2> <h3 id="题型一-反转链表"><a href="#题型一-反转链表" class="header-anchor">#</a> 题型一：反转链表</h3> <ol><li>将某个链表进行反转</li> <li>在 O(n) 时间, O(1) 空间复杂度下逆序读取链表的某个值</li> <li>将某个链表按 K 个一组进行反转</li></ol> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfih5wm9vzj31em080abx.jpg" alt="">
（图 1）</p> <h3 id="题型二-合并链表"><a href="#题型二-合并链表" class="header-anchor">#</a> 题型二：合并链表</h3> <ol><li>将两条有序或无序的链表合并成一条有序链表</li> <li>将 k 条有序链表合并成一条有序链表</li></ol> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfih6tlsicj310e0bwwh1.jpg" alt="">
（图 2）</p> <h3 id="题型三-相交或环形链表"><a href="#题型三-相交或环形链表" class="header-anchor">#</a> 题型三：相交或环形链表</h3> <ol><li>判断某条链表是否存在环</li> <li>获取某条链表环的大小</li> <li>获取某两条链表的相交节点</li></ol> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfihaxlmqej317q0lg41w.jpg" alt="">
（图 3）</p> <h3 id="题型四-设计题"><a href="#题型四-设计题" class="header-anchor">#</a> 题型四：设计题</h3> <p>要求设计一种数据结构，可以在指定的时间或空间复杂度下完成 XX 操作，这种题目的套路就是<strong>牢记所有基本数据结构的基本操作以及其复杂度</strong>。分析算法的瓶颈，并辅以恰当的数据结构进行优化。</p> <h2 id="常见套路"><a href="#常见套路" class="header-anchor">#</a> 常见套路</h2> <p>针对上面的四种题型， 我们分别介绍如何用套路进行应对。</p> <h3 id="套路一-反转链表"><a href="#套路一-反转链表" class="header-anchor">#</a> 套路一：反转链表</h3> <p>伪代码:</p> <div class="language- extra-class"><pre class="language-text"><code>当前指针 =  头指针
前一个节点 = null;
while 当前指针不为空 {
	下一个节点 = 当前指针.next;
    当前指针.next = 前一个节点
    前一个节点 = 当前指针
    当前指针 = 下一个节点
}
return 前一个节点;
</code></pre></div><p>JS 代码参考:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
<span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>
  pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
  cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> pre<span class="token punctuation">;</span>
</code></pre></div><p><strong>复杂度分析</strong></p> <ul><li>时间复杂度：<code>O(N)</code></li> <li>空间复杂度：<code>O(1)</code></li></ul> <h3 id="套路二-合并链表"><a href="#套路二-合并链表" class="header-anchor">#</a> 套路二：合并链表</h3> <p>伪代码:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code>ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// ans 为需要返回的头节点</span>
cur <span class="token operator">=</span> ans
<span class="token comment">// l1和l2分别为需要合并的两个链表的头节点</span>
<span class="token keyword">while</span> l1 和 l2 都不为空
    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
    更新较小的指针，往后移动一位
<span class="token keyword">if</span> l1 <span class="token operator">==</span> <span class="token keyword">null</span>
   cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l2
<span class="token keyword">if</span> l2 <span class="token operator">==</span> <span class="token keyword">null</span>
   cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l1
<span class="token keyword">return</span> ans<span class="token punctuation">.</span>next

</code></pre></div><p>JS 代码参考:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> ans <span class="token operator">=</span> <span class="token punctuation">(</span>now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    now<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>
    l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    now<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>
    l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  now <span class="token operator">=</span> now<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  now<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  now<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> ans<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
</code></pre></div><p><strong>复杂度分析</strong></p> <ul><li>时间复杂度：<code>O(N)</code></li> <li>空间复杂度：<code>O(1)</code></li></ul> <h3 id="套路三-相交或环形链表"><a href="#套路三-相交或环形链表" class="header-anchor">#</a> 套路三：相交或环形链表</h3> <h5 id="链表相交求交点"><a href="#链表相交求交点" class="header-anchor">#</a> 链表相交求交点</h5> <h6 id="解法一-哈希法"><a href="#解法一-哈希法" class="header-anchor">#</a> 解法一：哈希法</h6> <ul><li>有 A, B 这两条链表, 先遍历其中一个，比如 A 链表, 并将 A 中的所有节点存入哈希表。</li> <li>遍历 B 链表,检查节点是否在哈希表中, 第一个存在的就是相交节点</li></ul> <p>伪代码:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code>data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 存放A链表的所有节点的地址</span>

<span class="token keyword">while</span> <span class="token constant">A</span>不为空<span class="token punctuation">{</span>
  哈希表中添加<span class="token constant">A</span>链表当前节点
  <span class="token constant">A</span>指针向后移动
<span class="token punctuation">}</span>

<span class="token keyword">while</span> <span class="token constant">B</span>不为空<span class="token punctuation">{</span>
  <span class="token keyword">if</span> 如果哈希表中含有<span class="token constant">B</span>链表当前节点
    <span class="token keyword">return</span> <span class="token constant">B</span>
  <span class="token constant">B</span>指针向后移动
<span class="token punctuation">}</span>

<span class="token keyword">return</span> <span class="token keyword">null</span> <span class="token comment">// 两条链表没有相交点</span>
</code></pre></div><p>JS 代码参考:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token constant">A</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  data<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token constant">A</span> <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token constant">B</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">B</span><span class="token punctuation">;</span>
  <span class="token constant">B</span> <span class="token operator">=</span> <span class="token constant">B</span><span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>复杂度分析</strong></p> <ul><li>时间复杂度：<code>O(N)</code></li> <li>空间复杂度：<code>O(N)</code></li></ul> <h6 id="解法二-双指针"><a href="#解法二-双指针" class="header-anchor">#</a> 解法二：双指针</h6> <ul><li>例如使用 a, b 两个指针分别指向 A, B 这两条链表, 两个指针相同的速度向后移动,</li> <li>当 a 到达链表的尾部时,重定位到链表 B 的头结点</li> <li>当 b 到达链表的尾部时,重定位到链表 A 的头结点。</li> <li>a, b 指针相遇的点为相交的起始节点，否则没有相交点</li></ul> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfig7vsvwhj30bs05z3yl.jpg" alt="">
（图 5）</p> <p>为什么 a, b 指针相遇的点一定是相交的起始节点? 我们证明一下：</p> <ol><li>将两条链表按相交的起始节点继续截断，链表 1 为: A + C，链表 2 为: B + C</li> <li>当 a 指针将链表 1 遍历完后,重定位到链表 B 的头结点,然后继续遍历直至相交点(a 指针遍历的距离为 A + C + B)</li> <li>同理 b 指针遍历的距离为 B + C + A</li></ol> <p>伪代码:</p> <div class="language-js extra-class"><pre class="language-js"><code>a <span class="token operator">=</span> headA
b <span class="token operator">=</span> headB
<span class="token keyword">while</span> a<span class="token punctuation">,</span>b指针不相等时 <span class="token punctuation">{</span>
    <span class="token keyword">if</span> a指针为空时
      a指针重定位到链表 <span class="token constant">B</span>的头结点
    <span class="token keyword">else</span>
      a指针向后移动一位
    <span class="token keyword">if</span> b指针为空时
      b指针重定位到链表 <span class="token constant">A</span>的头结点
    <span class="token keyword">else</span>
      b指针向后移动一位
<span class="token punctuation">}</span>
<span class="token keyword">return</span> a
</code></pre></div><p>JS 代码参考:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">getIntersectionNode</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">headA<span class="token punctuation">,</span> headB</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> headA<span class="token punctuation">,</span>
    b <span class="token operator">=</span> headB<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    a <span class="token operator">=</span> a <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> headB <span class="token operator">:</span> a<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    b <span class="token operator">=</span> b <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> headA <span class="token operator">:</span> b<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>Python 代码参考：</p> <div class="language-py extra-class"><pre class="language-py"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> headA<span class="token punctuation">:</span> ListNode<span class="token punctuation">,</span> headB<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> ListNode<span class="token punctuation">:</span>
        a<span class="token punctuation">,</span> b <span class="token operator">=</span> headA<span class="token punctuation">,</span> headB
        <span class="token keyword">while</span> a <span class="token operator">!=</span> b<span class="token punctuation">:</span>
            a <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token keyword">if</span> a <span class="token keyword">else</span> headB
            b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token keyword">if</span> b <span class="token keyword">else</span> headA
        <span class="token keyword">return</span> a
</code></pre></div><p><strong>复杂度分析</strong></p> <ul><li>时间复杂度：<code>O(N)</code></li> <li>空间复杂度：<code>O(1)</code></li></ul> <h5 id="环形链表求环的起点"><a href="#环形链表求环的起点" class="header-anchor">#</a> 环形链表求环的起点</h5> <h6 id="解法一-哈希法-2"><a href="#解法一-哈希法-2" class="header-anchor">#</a> 解法一：哈希法</h6> <ul><li>遍历整个链表,同时将每个节点都插入哈希表,</li> <li>如果当前节点在哈希表中不存在,继续遍历,</li> <li>如果存在,那么当前节点就是环的入口节点</li></ul> <p>伪代码:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code>data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 声明哈希表</span>
<span class="token keyword">while</span> head不为空<span class="token punctuation">{</span>
  <span class="token keyword">if</span> 当前节点在哈希表中存在<span class="token punctuation">{</span>
    <span class="token keyword">return</span> head <span class="token comment">// 当前节点就是环的入口节点</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    将当前节点插入哈希表
  <span class="token punctuation">}</span>
  head指针后移
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token keyword">null</span> <span class="token comment">// 环不存在</span>
</code></pre></div><p>JS 代码参考:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    data<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>复杂度分析</strong></p> <ul><li>时间复杂度：<code>O(N)</code></li> <li>空间复杂度：<code>O(N)</code></li></ul> <h6 id="解法二-快慢指针法"><a href="#解法二-快慢指针法" class="header-anchor">#</a> 解法二：快慢指针法</h6> <ol><li><p>定义一个 fast 指针,每次<strong>前进两步</strong>,一个 slow 指针,每次<strong>前进一步</strong></p></li> <li><p>当两个指针相遇时</p> <ol><li>将 fast 指针指向链表头部,同时 fast 指针每次只<strong>前进一步</strong></li> <li>slow 指针继续前进,每次<strong>前进一步</strong></li></ol></li> <li><p>当两个指针再次相遇时,当前节点就是环的入口</p></li></ol> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfigbvzje1j30ky0bhq3x.jpg" alt="">
（图 6）</p> <p>为什么第二次相遇的点为环的入口? 原因如下：</p> <ul><li><strong>第一次相遇时</strong></li> <li>慢指针移动的距离为 s1 = A + B + n1 * L</li> <li>快指针移动的距离为 s2 = A + B + n2 * L</li> <li>快指针是慢指针速度的两倍,所以 s2 = 2* s1</li> <li>A + B + n2 * L = 2A + 2B + n1 * L ===&gt; A = -B + (n2 - n1) * L</li> <li>因为圆的性质 (n2 - n1) * L ===&gt; 绕圆 (n2 - n1) 圈 ===&gt; 0</li> <li>A = -B + (n2 - n1) * L ===&gt; A = -B</li> <li>即在第一次相遇点, 向前走 A 步 ===&gt; 向后走 B 步</li> <li><strong>第一次相遇后</strong></li> <li>快指针从头节点走 A 步会到达环的入口</li> <li>慢指针从第一次相遇点走 A 步,相当于向后走 B 步,也会到达环的入口</li></ul> <p>参考：<a href="https://github.com/azl397985856/leetcode/issues/274#issuecomment-573985706" target="_blank" rel="noopener noreferrer">【每日一题】- 2020-01-14 - 142. 环形链表 II<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>伪代码：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code>fast <span class="token operator">=</span> head
slow <span class="token operator">=</span> head <span class="token comment">//快慢指针都指向头部</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
  快指针向后两步
  慢指针向后一步
<span class="token punctuation">}</span> <span class="token keyword">while</span> 快慢指针不相等时
<span class="token keyword">if</span> 指针都为空时<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span> <span class="token comment">// 没有环</span>
<span class="token punctuation">}</span>
<span class="token keyword">while</span> 快慢指针不相等时<span class="token punctuation">{</span>
  快指针向后一步
  慢指针向后一步
<span class="token punctuation">}</span>
<span class="token keyword">return</span> fast
</code></pre></div><p>JS 代码参考：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> fast <span class="token operator">=</span> <span class="token punctuation">(</span>slow <span class="token operator">=</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    fast <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> slow<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> slow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> fast<span class="token punctuation">;</span>
</code></pre></div><p><strong>复杂度分析</strong></p> <ul><li>时间复杂度：<code>O(N)</code></li> <li>空间复杂度：<code>O(1)</code></li></ul> <h2 id="第3章-栈和队列"><a href="#第3章-栈和队列" class="header-anchor">#</a> 第3章 栈和队列</h2> <ul><li>栈和队列是限定插入和删除只能在表的“端点”进行的线性表。</li> <li>栈和队列是两种常用的线性表</li></ul> <h3 id="栈-stack"><a href="#栈-stack" class="header-anchor">#</a> 栈(stack)</h3> <h4 id="栈的基本概念"><a href="#栈的基本概念" class="header-anchor">#</a> 栈的基本概念</h4> <h5 id="栈的概念与特点"><a href="#栈的概念与特点" class="header-anchor">#</a> 栈的概念与特点</h5> <ul><li>只允许在一端插入和删除的线性表</li> <li>允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)</li> <li>特点
<ul><li>后进先出(LIFO)</li></ul></li></ul> <p><img src="/assets/img/ds_school/img/image-20201012092406784.png" alt=""></p> <h5 id="栈的基本操作"><a href="#栈的基本操作" class="header-anchor">#</a> 栈的基本操作</h5> <p>（1）int Length() const</p> <ul><li><p>初始条件：栈已存在。</p></li> <li><p>操作结果：返回栈元素个数。</p></li></ul> <p>（2）bool Empty() const</p> <ul><li><p>初始条件：栈已存在。</p></li> <li><p>操作结果：如栈为空，则返回true，否则返回false</p></li></ul> <p>（3）void Clear()</p> <ul><li><p>初始条件：栈已存在。</p></li> <li><p>操作结果：清空栈。</p></li></ul> <p>（4）void Traverse(void (visit)(const ElemType &amp;)) const</p> <ul><li><p>初始条件：栈已存在。</p></li> <li><p>操作结果：从栈底到栈顶依次对栈的每个元素调用函数(*visit)</p></li></ul> <p>（5）bool Push(const ElemType &amp;e)</p> <ul><li><p>初始条件：栈已存在。</p></li> <li><p>操作结果：插入元素e为新的栈顶元素。</p></li></ul> <p><img src="/assets/img/ds_school/img/image-20201012093039669.png" alt="image-20201012093039669"></p> <p>（6）bool Top(ElemTyfe &amp;e) const</p> <ul><li><p>初始条件：栈已存在且非空。</p></li> <li><p>操作结果：用e返回栈顶元素。</p></li></ul> <p><img src="/assets/img/ds_school/img/image-20201012093133462.png" alt="image-20201012093133462"></p> <p>（7）bool Pop(ElemType &amp;e)</p> <ul><li><p>初始条件：栈已存在且非空。</p></li> <li><p>操作结果：删除栈顶元素，并用e返回栈顶元素。</p></li></ul> <p><img src="/assets/img/ds_school/img/image-20201012093227716.png" alt="image-20201012093227716"></p> <h4 id="栈的数组表示-顺序栈"><a href="#栈的数组表示-顺序栈" class="header-anchor">#</a> 栈的数组表示——顺序栈</h4> <ul><li>在顺序实现中，利用数组依次存放从栈底到栈顶的数据元素</li> <li>用count存储数组中存储的栈的实际元素个数
<ul><li>当count = 0时表示栈为空</li> <li>入栈操作时，如栈未满，操作成功，count的值将加1</li> <li>出栈时，如栈不空，操作成功，并且count的值将减1</li></ul></li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 顺序栈类模板</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SqStack</span>
<span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
<span class="token comment">// 顺序栈的数据成员:</span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span>				<span class="token comment">// 元素个数</span>
    <span class="token keyword">int</span> maxSize<span class="token punctuation">;</span>			<span class="token comment">// 栈最大元素个数</span>
    ElemType <span class="token operator">*</span>elems<span class="token punctuation">;</span>		<span class="token comment">// 元素存储空间</span>
    
    <span class="token comment">// 辅助函数模板:</span>
    <span class="token keyword">bool</span> <span class="token function">Full</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>		<span class="token comment">// 判断栈是否已满</span>
    <span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 初始化栈</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment">// 抽象数据类型方法声明及重载编译系统默认方法声明:</span>
    <span class="token function">SqStack</span><span class="token punctuation">(</span><span class="token keyword">int</span> size <span class="token operator">=</span> DEFAULT_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 构造函数模板</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">SqStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>						<span class="token comment">// 析构函数模板</span>
    <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>						<span class="token comment">// 求栈长度</span>
    <span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>						<span class="token comment">// 判断栈是否为空</span>
    <span class="token keyword">void</span> <span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>							<span class="token comment">// 将栈清空</span>
    <span class="token keyword">void</span> <span class="token function">Traverse</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">// 遍历栈</span>
    <span class="token keyword">bool</span> <span class="token function">Push</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 入栈</span>
    <span class="token keyword">bool</span> <span class="token function">Top</span><span class="token punctuation">(</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>			<span class="token comment">// 返回栈顶</span>
    <span class="token keyword">bool</span> <span class="token function">Pop</span><span class="token punctuation">(</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 出栈</span>
    <span class="token function">SqStack</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqStack<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 复制构造函数模板</span>
    SqStack<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span>constSqStack<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//重载赋值运算符</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>复制构造函数模板</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token class-name">SqStack</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">SqStack</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqStack<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：由栈copy构造新栈——复制构造函数模板</span>
<span class="token punctuation">{</span>
    elems <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>				<span class="token comment">// 未分配存储空间前,elems为空</span>
    <span class="token function">Init</span><span class="token punctuation">(</span>copy<span class="token punctuation">.</span>maxSize<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 初始化新栈</span>
    count <span class="token operator">=</span> copy<span class="token punctuation">.</span>count<span class="token punctuation">;</span>			<span class="token comment">// 栈元素个数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> curPosition <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> curPosition <span class="token operator">&lt;=</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>curPosition<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 从栈底到栈顶对栈copy的每个元素进行复制</span>
        elems<span class="token punctuation">[</span>curPosition <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span>copy<span class="token punctuation">.</span>elems<span class="token punctuation">[</span>curPosition <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
SqStack<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>SqStack<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token keyword">operator</span> <span class="token operator">=</span>
<span class="token punctuation">(</span><span class="token keyword">const</span> SqStack<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：将栈copy赋值给当前栈——重载赋值运算符</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>copy <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">Init</span><span class="token punctuation">(</span>copy<span class="token punctuation">.</span>maxSize<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 初始化当前栈</span>
        count <span class="token operator">=</span> copy<span class="token punctuation">.</span>count<span class="token punctuation">;</span>		<span class="token comment">// 复制栈元素个数</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> curPosition <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> curPosition <span class="token operator">&lt;=</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> curPosition<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// 从栈底到栈顶对栈复制copy的元素</span>
            elems<span class="token punctuation">[</span>curPosition <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> copy<span class="token punctuation">.</span>elems<span class="token punctuation">[</span>curPosition <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="/assets/img/ds_school/img/image-20201012112950509.png" alt="image-20201012112950509"></p> <p><img src="/assets/img/ds_school/img/image-20201012112959497.png" alt="image-20201012112959497"></p> <p>双栈共享一个栈空间</p> <p><img src="/assets/img/ds_school/img/image-20201012113313024.png" alt="image-20201012113313024"></p> <h4 id="三、链式栈"><a href="#三、链式栈" class="header-anchor">#</a> 三、链式栈</h4> <h5 id="链式栈的基本概念"><a href="#链式栈的基本概念" class="header-anchor">#</a> 链式栈的基本概念</h5> <p><img src="/assets/img/ds_school/img/image-20201012113516074.png" alt="image-20201012113516074"></p> <ul><li>链式栈无栈满问题，空间可扩充</li> <li>插入与删除仅在栈顶处执行</li> <li>链式栈的栈顶在链头</li> <li>链式栈入栈和出栈操作都非常简单，一般都不使用头结点直接实现</li></ul> <h5 id="链式栈的类模板"><a href="#链式栈的类模板" class="header-anchor">#</a> 链式栈的类模板</h5> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 链栈类模板</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">LinkStack</span>
<span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
<span class="token comment">// 链栈实现的数据成员:</span>
	Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>top<span class="token punctuation">;</span>			<span class="token comment">// 栈顶指针</span>
<span class="token comment">// 辅助函数模板:</span>
	<span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 初始化栈</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment">// 抽象数据类型方法声明及重载编译系统默认方法声明:</span>
    <span class="token function">LinkStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 无参数的构造函数</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">LinkStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 析构函数</span>
    <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>				<span class="token comment">// 求栈长度</span>
    <span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>				<span class="token comment">// 判断栈是否为空</span>
    <span class="token keyword">void</span> <span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 将栈清空</span>
    <span class="token keyword">void</span> <span class="token function">Traverse</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>Visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">// 遍历栈</span>
    <span class="token keyword">bool</span> <span class="token function">Push</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 入栈</span>
    <span class="token keyword">bool</span> <span class="token function">Top</span><span class="token punctuation">(</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>	<span class="token comment">// 返回栈顶元素</span>
    <span class="token keyword">bool</span> <span class="token function">Pop</span><span class="token punctuation">(</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 出栈</span>
    <span class="token function">LinkStack</span><span class="token punctuation">(</span><span class="token keyword">const</span> LinkStack<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 复制构造函数模板</span>
    LinkStack<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> LinkStack<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//重载赋值</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="部分成员函数模板的实现"><a href="#部分成员函数模板的实现" class="header-anchor">#</a> 部分成员函数模板的实现</h5> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span> <span class="token class-name">LinkStack</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">LinkStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 操作结果：构造一个空栈表</span>
<span class="token punctuation">{</span>
	<span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span> LinkStack<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token operator">~</span><span class="token function">LinkStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 操作结果：销毁栈</span>
<span class="token punctuation">{</span>
	<span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token class-name">LinkStack</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：将元素e追加到栈顶,如成功则返加true,否则,如动态内存已耗尽将返回false</span>
<span class="token punctuation">{</span>
    Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>newTop <span class="token operator">=</span> <span class="token keyword">new</span> Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> top<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newTop <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 动态内存耗尽</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 操作成功</span>
        top <span class="token operator">=</span> newTop<span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>	<span class="token comment">// 元素个数自加1</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token class-name">LinkStack</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Pop</span><span class="token punctuation">(</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：如栈非空,删除栈顶元素,并用e返回栈顶元素,返回true,否则返回false</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>	<span class="token comment">// 栈空</span>
    	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>	<span class="token comment">// 操作成功</span>
        Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>old_top <span class="token operator">=</span> top<span class="token punctuation">;</span>	<span class="token comment">// 旧栈顶</span>
        e <span class="token operator">=</span> old_top<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>				<span class="token comment">// 用e返回栈顶元素</span>
        top <span class="token operator">=</span> old_top<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>			<span class="token comment">// top指向新栈顶</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>						<span class="token comment">// 元素个数自减1</span>
        <span class="token keyword">delete</span> old_top<span class="token punctuation">;</span>					<span class="token comment">// 删除旧栈顶</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token class-name">LinkStack</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Top</span><span class="token punctuation">(</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token comment">// 操作结果：如栈非空,用e返回栈顶元素,返回true,否则返回false</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 栈空</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 栈非空,操作成功</span>
        e <span class="token operator">=</span> top<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>			<span class="token comment">// 用e返回栈顶元素</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">LinkStack</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Traverse</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token comment">// 操作结果：从栈底到栈顶依次对栈的每个元素调用函数(*visit)</span>
<span class="token punctuation">{</span>
    Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>tmpPtr<span class="token punctuation">;</span>
    LinkStack<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> tmpS<span class="token punctuation">;</span><span class="token comment">// 临时栈</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>tmpPtr <span class="token operator">=</span> top<span class="token punctuation">;</span> tmpPtr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>tmpPtr <span class="token operator">=</span> tmpPtr<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 用tmpPtr依次指向当前栈的每个元素</span>
    	tmpS<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>tmpPtr<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 每个元素入栈</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>tmpPtr <span class="token operator">=</span> tmpS<span class="token punctuation">.</span>top<span class="token punctuation">;</span> tmpPtr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>tmpPtr <span class="token operator">=</span> tmpPtr<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 从栈顶到栈底依次指向栈tmpS的每个元素</span>
    	<span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span>tmpPtr<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="队列"><a href="#队列" class="header-anchor">#</a> 队列</h3> <h4 id="队列-queue-的基本概念"><a href="#队列-queue-的基本概念" class="header-anchor">#</a> 队列(Queue)的基本概念</h4> <h5 id="队列的初步认识"><a href="#队列的初步认识" class="header-anchor">#</a> 队列的初步认识</h5> <p><img src="/assets/img/ds_school/img/image-20201012114854942.png" alt=""></p> <ul><li>定义
<ul><li>队列是只允许在一端删除，在另一端插入的线性表</li> <li>允许删除的一端叫做队头(front)，允许插入的一端叫做队尾(rear)。</li></ul></li> <li>特性
<ul><li>先进先出(FIFO, First In First Out)</li></ul></li></ul> <h5 id="队列的基本操作"><a href="#队列的基本操作" class="header-anchor">#</a> 队列的基本操作</h5> <p>（1）int Length() const</p> <ul><li><p>初始条件：队列已存在。</p></li> <li><p>操作结果：返回队列长度</p></li></ul> <p>（2）bool Empty() const</p> <ul><li><p>初始条件：队列已存在。</p></li> <li><p>操作结果：如队列为空，则返回true，否则返回false</p></li></ul> <p>（3）void Clear()</p> <ul><li><p>初始条件：队列已存在。</p></li> <li><p>操作结果：清空队列</p></li></ul> <p>（4）void Traverse(void (*visit)(const ElemType &amp;)) const</p> <ul><li><p>初始条件：队列已存在。</p></li> <li><p>操作结果：依次对队列的每个元素调用函数(*visit)</p></li></ul> <p>（5）bool OutQueue(ElemType &amp;e)</p> <ul><li><p>初始条件：队列非空。</p></li> <li><p>操作结果：删除队头元素，并用e返回其值。</p></li></ul> <p><img src="/assets/img/ds_school/img/image-20201012115254050.png" alt="image-20201012115254050"></p> <p>（6）bool GetHead(ElemType &amp;e) const</p> <ul><li>初始条件：队列非空。</li> <li>操作结果：用e返回队头元素。</li></ul> <p><img src="/assets/img/ds_school/img/image-20201012115332350.png" alt="image-20201012115332350"></p> <p>（7）bool InQueue(const ElemType &amp;e)</p> <ul><li>初始条件：队列已存在。</li> <li>操作结果：插入元素e为新的队尾。</li></ul> <p><img src="/assets/img/ds_school/img/image-20201012115404331.png" alt="image-20201012115404331"></p> <h4 id="链队列"><a href="#链队列" class="header-anchor">#</a> 链队列</h4> <h5 id="链队列的基本概念"><a href="#链队列的基本概念" class="header-anchor">#</a> 链队列的基本概念</h5> <p><img src="/assets/img/ds_school/img/image-20201012115508391.png" alt="image-20201012115508391"></p> <ul><li>链式队列在入队时无队满问题，但有队空问题。</li> <li>队空条件为front ==rear</li></ul> <h5 id="链队列的类模板"><a href="#链队列的类模板" class="header-anchor">#</a> 链队列的类模板</h5> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">LinkQueue</span> 
<span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
<span class="token comment">// 链队列实现的数据成员:</span>
    Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>front<span class="token punctuation">,</span> <span class="token operator">*</span>rear<span class="token punctuation">;</span>			<span class="token comment">// 队头队尾指针</span>
<span class="token comment">// 辅助函数模板:</span>
    <span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 初始化队列</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment">// 抽象数据类型方法声明及重载编译系统默认方法声明:</span>
    <span class="token function">LinkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>							<span class="token comment">// 无参数的构造函数模板</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">LinkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 析构函数模板</span>
    <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>						<span class="token comment">// 求队列长度</span>
    <span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>						<span class="token comment">// 判断队列是否为空</span>
    <span class="token keyword">void</span> <span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>							<span class="token comment">// 将队列清空</span>
    <span class="token keyword">void</span> <span class="token function">Traverse</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>Visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>	<span class="token comment">// 遍历队列bool </span>
    <span class="token function">OutQueue</span><span class="token punctuation">(</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 出队操作</span>
    <span class="token keyword">bool</span> <span class="token function">GetHead</span><span class="token punctuation">(</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>		<span class="token comment">// 取队头操作</span>
    <span class="token keyword">bool</span> <span class="token function">InQueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 入队</span>
    <span class="token function">LinkQueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> LinkQueue<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 复制构造函数模板</span>
    LinkQueue<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span>constLinkQueue<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//重载赋值</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="循环队列-队列的顺序存储结构"><a href="#循环队列-队列的顺序存储结构" class="header-anchor">#</a> 循环队列——队列的顺序存储结构</h4> <h5 id="顺序队列的入队和出队"><a href="#顺序队列的入队和出队" class="header-anchor">#</a> 顺序队列的入队和出队</h5> <p><img src="/assets/img/ds_school/img/image-20201012115925941.png" alt="image-20201012115925941"></p> <h5 id="顺序队列的入队和出队原则"><a href="#顺序队列的入队和出队原则" class="header-anchor">#</a> 顺序队列的入队和出队原则</h5> <ul><li>入队时将新元素按rear指示位置加入再将队尾rear自加1: rear=rear+1。</li> <li>出队时将下标为front 的元素取出, 再将队头front自加1: front=front+1。</li> <li>队满时再入队将溢出出错；</li> <li>队空时再出队将队空处理。</li> <li>解决假溢出方法：将队列元素存放数组首尾相接，形成循环(环形)队列。</li></ul> <h5 id="循环队列-circular-queue"><a href="#循环队列-circular-queue" class="header-anchor">#</a> 循环队列(Circular Queue)</h5> <ul><li>队列存放数组被当作首尾相接的表处理。</li> <li>队头front、队尾rear自加1时从maxSize -1直接进到0，可用语言的取模(余数)运算实现。</li> <li>队头front自加1:front = (front+1) % maxSize;</li> <li>队尾rear自加1: rear = (rear+1) % maxSize;</li> <li>队列初始化：front= rear= 0;</li> <li>队空条件：front==rear 或Length() == 0;</li> <li>队满条件：(rear+1) % maxSize ==front或Length() == maxSize –1。</li></ul> <h5 id="循环队列入队和出队示意图"><a href="#循环队列入队和出队示意图" class="header-anchor">#</a> 循环队列入队和出队示意图</h5> <p><img src="/assets/img/ds_school/img/image-20201012120212793.png" alt="image-20201012120212793"></p> <h5 id="循环队列的类模板"><a href="#循环队列的类模板" class="header-anchor">#</a> 循环队列的类模板</h5> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SqQueue</span>
<span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span>		<span class="token comment">// 队头队尾</span>
    <span class="token keyword">int</span> maxSize<span class="token punctuation">;</span>			<span class="token comment">// 队列最大元素个数</span>
    ElemType <span class="token operator">*</span>elem<span class="token punctuation">;</span>			<span class="token comment">// 元素存储空间</span>
<span class="token comment">// 辅助函数模板:</span>
    <span class="token keyword">bool</span> <span class="token function">Full</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>		<span class="token comment">// 判断栈是否已满</span>
    <span class="token keyword">void</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 初始化队列</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment">// 抽象数据类型方法声明及重载编译系统默认方法声明:</span>
    <span class="token function">SqQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> size <span class="token operator">=</span> DEFAULT_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 构造函数模板</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">SqQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>									<span class="token comment">// 析构函数模板</span>
    <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>									<span class="token comment">// 求队列长度</span>
    <span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>									<span class="token comment">// 判断队列是否为空</span>
    <span class="token keyword">void</span> <span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>										<span class="token comment">// 将队列清空</span>
    <span class="token keyword">void</span> <span class="token function">Traverse</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span><span class="token comment">// 遍历队列</span>
    <span class="token keyword">bool</span> <span class="token function">OutQueue</span><span class="token punctuation">(</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>							<span class="token comment">// 出队操作</span>
    <span class="token keyword">bool</span> <span class="token function">GetHead</span><span class="token punctuation">(</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>					<span class="token comment">// 取队头操作</span>
    <span class="token keyword">bool</span> <span class="token function">InQueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 入队</span>
    <span class="token function">SqQueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> SqQueue<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 复制构造函数模板</span>
    SqQueue<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> qQueue<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//重载赋值运算符</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="部分成员函数模板的实现-2"><a href="#部分成员函数模板的实现-2" class="header-anchor">#</a> 部分成员函数模板的实现</h5> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token class-name">SqQueue</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Full</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token comment">// 操作结果：如队列已满，则返回true，否则返回false</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> maxSize <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">SqQueue</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 操作结果：初始化队列</span>
<span class="token punctuation">{</span>
	rear <span class="token operator">=</span> front <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token class-name">SqQueue</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token comment">// 操作结果：返回队列长度</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>rear <span class="token operator">-</span>front <span class="token operator">+</span> maxSize<span class="token punctuation">)</span> <span class="token operator">%</span> maxSize<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">SqQueue</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Traverse</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token comment">// 操作结果：依次对队列的每个元素调用函数(*visit)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> curPosition <span class="token operator">=</span> front<span class="token punctuation">;</span> curPosition <span class="token operator">!=</span> rear<span class="token punctuation">;</span>curPosition <span class="token operator">=</span> <span class="token punctuation">(</span>curPosition <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> maxSize<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 对队列每个元素调用函数(*visit)</span>
    	<span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span>elem<span class="token punctuation">[</span>curPosition<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token class-name">LinkQueue</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">OutQueue</span><span class="token punctuation">(</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：如果队列非空，那么删除队头元素，并用e返回其值，返回true, 否则返回false，</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 队列非空</span>
        Node<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>tmpPtr <span class="token operator">=</span> front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>	<span class="token comment">// 指向队列头素</span>
        e <span class="token operator">=</span> tmpPtr<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>						<span class="token comment">// 用e返回队头元素</span>
        front<span class="token operator">-&gt;</span>next <span class="token operator">=</span> tmpPtr<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>				<span class="token comment">// front指向下一元素</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>rear <span class="token operator">==</span> tmpPtr<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// 表示出队前队列中只有一个元素，出队后为空队列</span>
            rear <span class="token operator">=</span> front<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">delete</span> tmpPtr<span class="token punctuation">;</span>							<span class="token comment">// 释放出队的结点</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>								<span class="token comment">// 元素个数自减1</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 队列为空</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="实例研究-表达式求值"><a href="#实例研究-表达式求值" class="header-anchor">#</a> 实例研究——表达式求值</h3> <h4 id="一、表达式基础"><a href="#一、表达式基础" class="header-anchor">#</a> 一、表达式基础</h4> <ul><li>表达式由操作数(亦称运算对象)、操作符(亦称运算符)和分界符组成。</li> <li>算术表达式有三种表示：
<ul><li>中缀(infix)表示
&lt;操作数&gt;&lt;操作符&gt;&lt;操作数&gt;，如A+B；</li> <li>前缀(prefix)表示
&lt;操作符&gt;&lt;操作数&gt;&lt;操作数&gt;，如+AB；</li> <li>后缀(postfix)表示
&lt;操作数&gt; &lt;操作数&gt; &lt;操作符&gt;，如AB+；</li></ul></li></ul> <h4 id="二、表达式的中缀表示"><a href="#二、表达式的中缀表示" class="header-anchor">#</a> 二、表达式的中缀表示</h4> <p>表达式中相邻两个操作符的计算次序为：</p> <ul><li>优先级高的先计算；</li> <li>优先级相同的自左向右计算；</li> <li>当使用括号时从最内层括号开始计算。</li></ul> <h4 id="三、算符优先法"><a href="#三、算符优先法" class="header-anchor">#</a> 三、算符优先法</h4> <ul><li>算符优先法就是根据上面的运算符优先关系来实现对表达式进行编译执行</li> <li>任何表达式都可看成由操作数（operand）、操作符（operator）和界限符（delimiter）组成</li> <li>为简单起见，只讨论算要四则运算符（“==+==”、“==-==”、“==*==”、“==/==”），操作数为常数，界限符为左右圆括和等号==（==“==（==”，“==）==”，“=====”）；</li></ul> <h4 id="四、操作符的优先级"><a href="#四、操作符的优先级" class="header-anchor">#</a> 四、操作符的优先级</h4> <p>对于任意两个操作符theta1和theta2的优先关系如下：</p> <ol><li>theta1&lt; theta2：theta1优先级低于theta2。</li> <li>theta1= theta2：theta1优先级等于theta2。</li> <li>theta1&gt; theta2：theta1优先级高于theta2。</li> <li>theta1e theta2：theta1与theta2不允许相继出现</li></ol> <p><img src="/assets/img/ds_school/img/image-20201012121949166.png" alt="image-20201012121949166"></p> <p>操作符优先级相等的情况只出现在括号配对或左右操作符都是'='的情形。</p> <h4 id="五、中缀算术表达式求值算法"><a href="#五、中缀算术表达式求值算法" class="header-anchor">#</a> 五、中缀算术表达式求值算法</h4> <ul><li>使用两个栈，操作符栈optr(operator)，操作数栈opnd(operand)，</li> <li>对中缀表达式求值的一般规则：
<ol><li>在optr栈中压入一个'='。</li> <li>从输入流获取一字符ch。</li> <li>取出optr的栈顶optrTop。</li> <li>当optrTop!='='或ch!='='时,循环执行以下工作,否则结束算法。此时在opnd栈的栈顶得到运算结果。</li></ol></li></ul> <p>while(optrTop!='='||ch!='=')
{
1. 若ch不是操作符，则将字符放回输入流(cin.putback)，读操作数operand并进opnd栈，并读入下一字符送入ch；
2. 若ch是操作符，将比较ch的优先级和optrTop的优先级：
* 若optrTop&lt;ch，则ch进optr栈，从中缀表达式取下一字符送入ch；
* 若optrTop&gt;ch，则从opnd栈退出a2和a1，从optr栈退出θ,形成运算指令(a1)θ(a2)，结果进opnd栈；
* 若optrTop=ch(此处特指optrTop与ch的优先级相等)且ch==')'，此时optrTop为'('，则从optr栈退出栈顶的‘(’，对消括号，然后从中缀表达式取下一字符送入ch；
* 若optrTopech，则出现表达式错误，终止执行。
3. 取出optr的栈顶optrTop。</p> <p>}</p> <h4 id="六、中缀表达式中操作符的优先级的另一个表示方法"><a href="#六、中缀表达式中操作符的优先级的另一个表示方法" class="header-anchor">#</a> 六、中缀表达式中操作符的优先级的另一个表示方法</h4> <table><thead><tr><th>操作符ch</th> <th>‘='</th> <th>‘('</th> <th>'*', '/', '%'</th> <th>'+', '-'</th> <th>')'</th></tr></thead> <tbody><tr><td>Isp (栈内)</td> <td>0</td> <td>1</td> <td>5</td> <td>3</td> <td>6</td></tr> <tr><td>Icp (栈外)</td> <td>0</td> <td>6</td> <td>4</td> <td>2</td> <td>1</td></tr></tbody></table> <ul><li>Isp叫做栈内(instackpriority)优先数，实际为表达式中左操作符的优先数。</li> <li>Icp叫做栈外(incomingpriority)优先数，实际为表达式中右操作符的优先数。</li> <li>操作符优先数相等的情况只出现在括号配对或栈底的'='号与输入流最后的'='号配对时。</li></ul> <h4 id="七、中缀算术表达式求值的另一种算法"><a href="#七、中缀算术表达式求值的另一种算法" class="header-anchor">#</a> 七、中缀算术表达式求值的另一种算法</h4> <ul><li>用两个栈，操作符栈optr(operator)，操作数栈opnd(operand)，</li> <li>对中缀表达式求值的一般规则：
<ol><li>在optr栈中压入一个'='。</li> <li>从输入流获取一字符ch。</li> <li>取出optr的栈顶optrTop。</li> <li>当<code>optrTop!='='</code>或<code>ch!='='</code>时,循环执行以下工作,否则结束算法。此时在opnd栈的栈顶得到运算结果。</li></ol></li></ul> <p>while(optrTop!='='||ch!='='){</p> <ol><li><p>若ch不是操作符，则将字符放回输入流(cin.putback)，读操作数operand并进opnd栈，并读入下一字符送入ch；</p></li> <li><p>若ch是操作符，比较Icp(ch)的优先级和Isp(optrTop)的优先级：</p> <ul><li>若Isp(optrTop)&lt;Icp(ch)，则ch进optr栈，从中缀表达式取下一字符送入ch；</li> <li>若Isp(optrTop)&gt;Icp(ch)，则从opnd栈退出a2和a1，从optr栈退出θ,形成运算指令(a1)θ(a2)，结果进opnd栈；</li> <li>若Isp(optrTop)==Icp(ch)且ch==')'，则从optr栈退出栈顶的'('，对消括号，然后从中缀表达式取下一字符送入ch。</li> <li>取出optr的栈顶optrTop。</li></ul> <p>}</p></li></ol> <h2 id="第-4-章-串"><a href="#第-4-章-串" class="header-anchor">#</a> 第 4 章 串</h2> <h3 id="串类型的定义"><a href="#串类型的定义" class="header-anchor">#</a> 串类型的定义</h3> <h4 id="一、串的定义"><a href="#一、串的定义" class="header-anchor">#</a> 一、串的定义</h4> <p>n(n&gt;=0)个字符的有限序列</p> <ul><li>s=&quot;a1 ,a2 ,…,an &quot;</li> <li>串名: s</li> <li>串值: a<sub>i</sub> (1≤i ≤ n)</li> <li>串长: n</li></ul> <h4 id="二、串的基本术语"><a href="#二、串的基本术语" class="header-anchor">#</a> 二、串的基本术语</h4> <ul><li>空串
<ul><li>n=0的串</li></ul></li> <li>子串
<ul><li>串中若干相邻字符组成的子序列</li></ul></li> <li>主串
<ul><li>包含子串的串</li></ul></li> <li>空格串
<ul><li>仅含有空格字符的串(n不为0)</li></ul></li> <li>串相等
<ul><li>设 s1=&quot;a11,…,an1 &quot; s2=&quot;a12,…,an2 &quot; 若 n1=n2且ai1=ai2（1≤i≤n1) 则 s1=s2</li></ul></li></ul> <h4 id="三、串的基本术语"><a href="#三、串的基本术语" class="header-anchor">#</a> 三、串的基本术语</h4> <ol><li><p>void Copy(String &amp;copy, const String &amp;original)</p> <ul><li>初始条件：串 original 已存在。</li> <li>操作结果：将串 original 复制得到一个串 copy 。</li></ul></li> <li><p>bool Empty() const</p> <ul><li><p>初始条件：串已存在。</p></li> <li><p>操作结果：如串为空，则返回 true ，否则返回 false 。</p></li></ul></li> <li><p>int Length() const</p> <ul><li><p>初始条件：串已存在。</p></li> <li><p>操作结果：返回串的长度，即串中的字符个数。</p></li></ul></li> <li><p>void Concat (String &amp;addTo , const String &amp;addOn)</p> <ul><li>初始条件：串 addTo 和 addOn 已存在。</li> <li>操作结果：将串 addOn 联接到串 addTo 的后面。</li></ul></li> <li><p>String SubString (const String &amp;s, int pos,int len)</p> <ul><li>初始条件：串存在，且 0≤pos s.Length,0≤ len ≤ s.Length () pos 。</li> <li>操作结果：返回从第 pos 个字符开始长度为len 的子串。</li></ul></li> <li><p>int Index(const String &amp;target, const String &amp;pattern, int pos = 0)</p> <ul><li>初始条件：目标串 target 和串 pattern 都存在，模式串 pattern 非空，且 0 ≤ pos &lt; target.Length() 。</li> <li>操作结果：返回目标串 target 中第 pos 个字符后第一次出现的模式串 pattern 的位置。</li></ul></li></ol> <h3 id="字符串的实现"><a href="#字符串的实现" class="header-anchor">#</a> 字符串的实现</h3> <ul><li>在 C++ 在头文件 string 中已含了一种安全的字符串实现</li> <li>由于这个库没有包含在一些较老的C++ 编译器中，因此本节将设计自已的安全的 String 类，使用面向对象技术来克服 C 风格的串中存在的问题。</li></ul> <h4 id="串类及串相关操作"><a href="#串类及串相关操作" class="header-anchor">#</a> 串类及串相关操作</h4> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 串类</span>
<span class="token keyword">class</span> <span class="token class-name">String</span>
<span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
<span class="token comment">// 串实现的数据成员</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>strVal<span class="token punctuation">;</span>		<span class="token comment">// 串值</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span> 		<span class="token comment">// 串长</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment">// 抽象数据类型方法声明及重载编译系统默认方法声明</span>
    <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>						<span class="token comment">// 构造函数</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">// 析构函数</span>
    <span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 复制构造函数</span>
    <span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 从 C 风格串转换的构造函数</span>
    <span class="token function">String</span><span class="token punctuation">(</span>LinkList<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 从线性表转换的构造函数</span>
    <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>				<span class="token comment">// 求串长度</span>
    <span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>				<span class="token comment">// 判断串是否为空</span>
    String <span class="token operator">&amp;</span><span class="token keyword">operator</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 重载赋值运算符</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">CStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>				<span class="token comment">// 将串转换成 C 风格串</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">&amp;</span>String<span class="token operator">::</span><span class="token keyword">operator</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>	<span class="token comment">// 重载下标运算符</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//串相关操作</span>
String <span class="token function">Read</span><span class="token punctuation">(</span> istream <span class="token operator">&amp;</span> input<span class="token punctuation">)</span><span class="token punctuation">;</span>							<span class="token comment">// 从输入流读入串</span>
String <span class="token function">Read</span><span class="token punctuation">(</span> istream input<span class="token punctuation">,</span><span class="token keyword">char</span> terminalChar<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 从输入流读入串 用 terminalChar 返回串结束字符</span>
<span class="token keyword">void</span> <span class="token function">Write</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>							<span class="token comment">// 输出串</span>
<span class="token keyword">void</span> <span class="token function">Concat</span> <span class="token punctuation">(</span>String <span class="token operator">&amp;</span>addTo <span class="token punctuation">,</span> <span class="token keyword">const</span> String <span class="token operator">&amp;</span>addOn<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 将串 addOn 连接到 addTo 串的后面</span>
<span class="token keyword">void</span> <span class="token function">Copy</span><span class="token punctuation">(</span>String <span class="token operator">&amp;</span>copy<span class="token punctuation">,</span> <span class="token keyword">const</span> String <span class="token operator">&amp;</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 将串 original 复制到串 copy</span>
<span class="token keyword">void</span> <span class="token function">Copy</span><span class="token punctuation">(</span>String <span class="token operator">&amp;</span>copy<span class="token punctuation">,</span> <span class="token keyword">const</span> String <span class="token operator">&amp;</span>original<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 将串 original 复制 n 个字符到串 copy</span>
<span class="token keyword">int</span> <span class="token function">Index</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>target<span class="token punctuation">,</span> <span class="token keyword">const</span> String <span class="token operator">&amp;</span>pattern<span class="token punctuation">,</span><span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 查找模式串 pattern 第一次在目标串 target 中从第pos 个字符开始出现的位置</span>
String <span class="token function">SubString</span> <span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 求串 s 的第 pos 个字符开始的长度为 len 的子串</span>
<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>first<span class="token punctuation">,</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 重载关系运算符</span>
<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>first<span class="token punctuation">,</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 重载关系运算符</span>
<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>first<span class="token punctuation">,</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 重载关系运算符</span>
<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;=</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>first<span class="token punctuation">,</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 重载关系运算符</span>
<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&gt;=</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>first<span class="token punctuation">,</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 重载关系运算符</span>
<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>first<span class="token punctuation">,</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 重载关系运算符</span>
</code></pre></div><h4 id="串类部分成员函数的实现"><a href="#串类部分成员函数的实现" class="header-anchor">#</a> 串类部分成员函数的实现</h4> <h5 id="串构造函数-1"><a href="#串构造函数-1" class="header-anchor">#</a> 串构造函数(1)</h5> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>inString<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：从 C 风格串转换构造新串——转换构造函数</span>
<span class="token punctuation">{</span>
	length <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>inString<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 串长</span>
	strVal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">// 分配存储空间</span>
	<span class="token function">strcpy</span><span class="token punctuation">(</span>strVal<span class="token punctuation">,</span> inString<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 复制串值</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="串构造函数-2"><a href="#串构造函数-2" class="header-anchor">#</a> 串构造函数(2)</h5> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">String</span><span class="token punctuation">(</span>LinkList<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span>
<span class="token comment">//操作结果：从线性表转换构造新串——转换构造函数</span>
<span class="token punctuation">{</span>
    length <span class="token operator">=</span> copy<span class="token punctuation">.</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 串长</span>
    strVal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">// 分配存储空间</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 复制串值</span>
    	copy<span class="token punctuation">.</span><span class="token function">GetElem</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> strVal<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    strVal<span class="token punctuation">[</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>				<span class="token comment">// 串值以 0' 结束</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="将-c-串转换为-c-语言串"><a href="#将-c-串转换为-c-语言串" class="header-anchor">#</a> 将 C++ 串转换为 C 语言串</h5> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">CStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token comment">// 操作结果：将串转换成 C 风格串</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>strVal<span class="token punctuation">;</span>	<span class="token comment">// 串值类型转换</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="串比较实现"><a href="#串比较实现" class="header-anchor">#</a> 串比较实现</h5> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>first<span class="token punctuation">,</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>second<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：重载关系运算符</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">CStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> second<span class="token punctuation">.</span><span class="token function">CStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>first<span class="token punctuation">,</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>second<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：重载关系运算符</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">CStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> second<span class="token punctuation">.</span><span class="token function">CStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="进一步串操作示例"><a href="#进一步串操作示例" class="header-anchor">#</a> 进一步串操作示例</h5> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">Concat</span><span class="token punctuation">(</span>String <span class="token operator">&amp;</span>addTo<span class="token punctuation">,</span> <span class="token keyword">const</span> String <span class="token operator">&amp;</span>addOn<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：将串 addOn 连接到 addTo 串的后面</span>
<span class="token punctuation">{</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cFirst <span class="token operator">=</span> addTo<span class="token punctuation">.</span><span class="token function">CStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 指向第一个串</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cSecond <span class="token operator">=</span> addOn<span class="token punctuation">.</span><span class="token function">CStr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 指向第二个串</span>
<span class="token keyword">char</span> <span class="token operator">*</span>copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>cFirst<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>cSecond<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">// 分配存储空间</span>
<span class="token function">strcpy</span><span class="token punctuation">(</span>copy<span class="token punctuation">,</span> cFirst<span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 复制第一个串</span>
<span class="token function">strcat</span><span class="token punctuation">(</span>copy<span class="token punctuation">,</span> cSecond<span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 连接第二个串</span>
addTo <span class="token operator">=</span> copy<span class="token punctuation">;</span>							<span class="token comment">// 串赋值</span>
<span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>copy<span class="token punctuation">;</span>							<span class="token comment">// 释放 copy</span>
</code></pre></div><h3 id="字符串模式匹配算法"><a href="#字符串模式匹配算法" class="header-anchor">#</a> 字符串模式匹配算法</h3> <h5 id="简单字符串模式匹配算法"><a href="#简单字符串模式匹配算法" class="header-anchor">#</a> 简单字符串模式匹配算法</h5> <p><img src="/assets/img/ds_school/img/image-20201109102309497.png" alt="image-20201109102309497"></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">SimpleIndex</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>T<span class="token punctuation">,</span> <span class="token keyword">const</span> String <span class="token operator">&amp;</span>P<span class="token punctuation">,</span><span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token comment">// 操作结果 : 查找模式串 P 第一次在目标串 T 中从第 pos 个字符开始出现的位置</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> startPos <span class="token operator">=</span> pos <span class="token punctuation">,</span> i <span class="token operator">=</span> pos <span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span> i <span class="token operator">&lt;</span> T<span class="token punctuation">.</span><span class="token function">Length</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> P<span class="token punctuation">.</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> P<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// 继续比较后续字符</span>
        	i <span class="token operator">++</span><span class="token punctuation">;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// 指针回退 重新开始新的匹配</span>
        	i <span class="token operator">=</span> <span class="token operator">++</span>startPos<span class="token punctuation">;</span>
            j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> P<span class="token punctuation">.</span><span class="token function">Length</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> startPos <span class="token punctuation">;</span>	<span class="token comment">// 匹配成功</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>			<span class="token comment">// 匹配失败</span>
</code></pre></div><h5 id="首尾字符串模式匹配算法"><a href="#首尾字符串模式匹配算法" class="header-anchor">#</a> 首尾字符串模式匹配算法</h5> <ul><li>在简单字符串模式匹配算法中，分析匹配执行时间的最坏情况是每趟匹配过程都是在比较到模式串的最后一个字符时才发现不能匹配。</li> <li>为避免在每趟匹配的最后一个字符时才发现不能匹配，可采用从模式串的两头分别进行比较的方法。</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">FrontRearIndex</span><span class="token punctuation">(</span><span class="token keyword">const</span> String <span class="token operator">&amp;</span>T<span class="token punctuation">,</span> <span class="token keyword">const</span> String <span class="token operator">&amp;</span>P<span class="token punctuation">,</span><span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 操作结果 : 查找模式串 P 第一次在目标串 T 中从第 pos 个字符开始出现的位置</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> startPos <span class="token operator">=</span> pos<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span> startPos <span class="token operator">&lt;=</span> T<span class="token punctuation">.</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> P<span class="token punctuation">.</span><span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> front <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rear <span class="token operator">=</span> P<span class="token punctuation">.</span><span class="token function">Length</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>	<span class="token comment">// 模式串的首尾部字符位置</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>front <span class="token operator">&lt;=</span> rear<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span>startPos <span class="token operator">+</span> front<span class="token punctuation">]</span> <span class="token operator">!=</span> P<span class="token punctuation">[</span>front<span class="token punctuation">]</span> <span class="token operator">||</span> T<span class="token punctuation">[</span>startPos <span class="token operator">+</span> rear<span class="token punctuation">]</span> <span class="token operator">!=</span> P<span class="token punctuation">[</span>rear<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            	<span class="token comment">// 模式串的首部或尾部字符不匹配,退出内循环</span>
			<span class="token keyword">else</span>
            <span class="token punctuation">{</span>
                front<span class="token operator">++</span><span class="token punctuation">;</span>
                rear <span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token comment">// 首尾部字符匹配 , 重新定位新的首尾部字符</span>
        <span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>front <span class="token operator">&gt;</span> rear<span class="token punctuation">)</span>
            <span class="token keyword">return</span> startPos<span class="token punctuation">;</span><span class="token comment">// 匹配成功</span>
		<span class="token keyword">else</span> 
            <span class="token operator">++</span>startPos<span class="token punctuation">;</span><span class="token comment">// 首部或尾部部字符不匹配重新查找匹配起始点</span>
    <span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 匹配失败</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="第-5-章-数组和广义表"><a href="#第-5-章-数组和广义表" class="header-anchor">#</a> 第 5 章 数组和广义表</h2> <h3 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h3> <h4 id="数组元素的存储顺序"><a href="#数组元素的存储顺序" class="header-anchor">#</a> 数组元素的存储顺序</h4> <ol><li>以行序为主序（按行排列）:
先排最右的下标依次向左，最后排最左的下标</li> <li>以列序为主序（按列排列）：
先排最左的下标，依次向右，最后排最右的下标</li></ol> <h4 id="二维数组元素的存储位置"><a href="#二维数组元素的存储位置" class="header-anchor">#</a> 二维数组元素的存储位置</h4> <h5 id="c-中二维数组的元素的存储位置"><a href="#c-中二维数组的元素的存储位置" class="header-anchor">#</a> C 中二维数组的元素的存储位置</h5> <p>例如:</p> <table><tr><td>a<sub>0,0</sub></td> <td>a<sub>0,1</sub></td> <td>a <sub>0,2</sub></td></tr> <tr><td>a<sub>1,0</sub></td> <td>a<sub>1,1</sub></td> <td>a<sub>1,2</sub></td></tr></table> <table><tr><td>a<sub>0,0</sub></td> <td>a<sub>0,1</sub></td> <td>a <sub>0,2</sub></td> <td>a<sub>1,0</sub></td> <td>a<sub>1,1</sub></td> <td>a<sub>1,2</sub></td></tr></table> <p>二维数组<code>a[b1][b2]</code>中任一元素 a<sub>i,j</sub>的存储位置</p> <center>Loc(i,j) = Loc(0,0) + (b<sub>2</sub> × i + j) × L</center> <p>其中Loc(0,0)称为基地址或基址。</p> <h4 id="n-维数组元素的存储位置"><a href="#n-维数组元素的存储位置" class="header-anchor">#</a> n 维数组元素的存储位置</h4> <p>推广到一般情况，可得到n 维数组数据元素按行序的存储位置有如下的关系</p> <p><img src="/assets/img/ds_school/img/image-20201109105544562.png" alt="image-20201109105544562"></p> <p>其中c<sub>n</sub> = L,c<sub>i - 1</sub> = b<sub>i</sub> × c<sub>i</sub> , 1 &lt; i ≤ n</p> <p>数组元素的存储位置是其下标的线性函数。</p> <h3 id="矩阵"><a href="#矩阵" class="header-anchor">#</a> 矩阵</h3> <h4 id="特殊矩阵"><a href="#特殊矩阵" class="header-anchor">#</a> 特殊矩阵</h4> <h5 id="特殊矩阵的概念"><a href="#特殊矩阵的概念" class="header-anchor">#</a> 特殊矩阵的概念</h5> <p>特殊矩阵指元素（特别是非零元素）在矩阵中的分布有一定规则
例如：</p> <ul><li>对称矩阵</li> <li>三角矩阵</li> <li>三对角矩阵</li></ul> <h5 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="header-anchor">#</a> 对称矩阵的压缩存储</h5> <p><img src="/assets/img/ds_school/img/image-20201109110027486.png" alt="image-20201109110027486"></p> <h5 id="三角矩阵的压缩存储"><a href="#三角矩阵的压缩存储" class="header-anchor">#</a> 三角矩阵的压缩存储</h5> <p><img src="/assets/img/ds_school/img/image-20201109110107030.png" alt="image-20201109110107030"></p> <h5 id="对角矩阵的压缩存储"><a href="#对角矩阵的压缩存储" class="header-anchor">#</a> 对角矩阵的压缩存储</h5> <p><img src="/assets/img/ds_school/img/image-20201109110139603.png" alt="image-20201109110139603"></p> <h4 id="稀疏矩阵"><a href="#稀疏矩阵" class="header-anchor">#</a> 稀疏矩阵</h4> <h5 id="稀疏矩阵的基本概念"><a href="#稀疏矩阵的基本概念" class="header-anchor">#</a> 稀疏矩阵的基本概念</h5> <p><img src="/assets/img/ds_school/img/image-20201109110229377.png" alt="image-20201109110229377"></p> <p>稀疏矩阵是非零元素个数远远少于矩阵元素个数的矩阵</p> <ul><li>以常规方法，即以二维数组表示高阶的稀疏矩阵时产生的问题：
<ol><li>零值元素占了很大空间</li> <li>计算中进行了很多和零值的运算，遇除法，还需判别除数是否为零</li></ol></li></ul> <p>解决问题的原则</p> <ol><li><p>尽可能少存或不存零值元素；</p></li> <li><p>尽可能减少没有实际意义的运算；</p></li> <li><p>操作方便。 即能尽可能快地找到与下标值( i , j ) 对应的元素，</p></li></ol> <h5 id="稀疏矩阵的基本操作"><a href="#稀疏矩阵的基本操作" class="header-anchor">#</a> 稀疏矩阵的基本操作</h5> <ol><li>int GetRows () const
<ul><li>初始条件：稀疏矩阵已存在。</li> <li>操作结果：返回稀疏矩阵行数。</li></ul></li> <li>int GetCols () const
<ul><li>初始条件：稀疏矩阵已存在。</li> <li>操作结果：返回稀疏矩阵列数。</li></ul></li> <li>int GetNum () const
<ul><li>初始条件：稀疏矩阵已存在。</li> <li>操作结果：返回稀疏矩阵非零元素个数。</li></ul></li> <li>bool Empty() const
<ul><li>初始条件：稀疏矩阵已存在。</li> <li>操作结果：如稀疏矩阵为空，则返回 true否则返回 false</li></ul></li> <li>bool SetElem(int r, int c, constElemType &amp;v)
<ul><li>初始条件：稀疏矩阵已存在。</li> <li>操作结果：设置指定位置的元素值。</li></ul></li> <li>bool GetElem(int r, int c, ElemType &amp;v)
<ul><li>初始条件：稀疏矩阵已存在。</li> <li>操作结果：求指定位置的元素值。</li></ul></li></ol> <h4 id="稀疏矩阵的存储方式"><a href="#稀疏矩阵的存储方式" class="header-anchor">#</a> 稀疏矩阵的存储方式</h4> <ul><li>稀疏矩阵的顺序压缩存储
<ul><li>三元组表示法</li></ul></li> <li>稀疏矩阵的链式压缩存储
<ul><li>十字链表</li></ul></li></ul> <ol><li><p>三元组顺序表</p> <ul><li><p>当稀疏矩阵的阶很高时，如采用一般矩阵的存储方法将浪费大量的存储空间。</p></li> <li><p>一种直观、常用的方法是，对每个非零元素，用三元组（行号，列号，元素值）来表示，这样每个元素的信息就全部记录下来了。</p></li> <li><p>以顺序表存储三元组表，可得到稀疏矩阵的顺序存储结构——三元组顺序表</p></li> <li><p>在三元组顺序表中，用三元组表表示稀疏矩阵时，为避免丢失信息，增设了一个信息元组，形式为：</p> <center>（行数，列数，非零元素个数）</center></li></ul> <p>三元组顺序表示例</p> <p><img src="/assets/img/ds_school/img/image-20201109111255309.png" alt="image-20201109111255309"></p></li> <li><p>十字链表</p> <p><img src="/assets/img/ds_school/img/image-20201109111330736.png" alt="image-20201109111330736"></p></li></ol> <h3 id="广义表"><a href="#广义表" class="header-anchor">#</a> 广义表</h3> <h4 id="广义表基础"><a href="#广义表基础" class="header-anchor">#</a> 广义表基础</h4> <ol><li>广义表的概念，广义表通常简称为表，由 n(≥0)个表元素组成的有限序列 记作 GL =(a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub> , …, a<sub>n</sub>)，GL 是表名，a<sub>i</sub>为表元素，简称为元素，它可以是表（称为子表元素，简称为子表），可以是数据元素（称为原子元素，简称为原子）</li> <li>n 为表的长度。 n = 0 的广义表为空表</li> <li>n &gt; 0 时，表的第一个表元素称为广义表的表头(head)，除此之外，其它表元素组成的表称为广义表的表尾(tail)</li></ol> <p>由于广义表中的元素又可以是广义表，因此对于广义表有深度的概念。广义表 GL 的深度 Depth(GL) 定义如下：<img src="/assets/img/ds_school/img/image-20201109111940655.png" alt="image-20201109111940655"></p> <p>广义表的深度本质上就是广义表表达式中括号的最大嵌套层数。例如：</p> <div class="language-txt extra-class"><pre class="language-text"><code>2				深度为 0( 括号层数为 0)
()				深度为 1( 括号层数为 1)
(2,(3,6))		深度为 2( 括号层数为 2)
</code></pre></div><p>求广义表的深度</p> <p><img src="/assets/img/ds_school/img/image-20201109112136284.png" alt=" "></p> <h2 id="第-6-章-树和二叉树"><a href="#第-6-章-树和二叉树" class="header-anchor">#</a> 第 6 章 树和二叉树</h2> <h3 id="树的基本概念"><a href="#树的基本概念" class="header-anchor">#</a> 树的基本概念</h3> <h4 id="树的定义"><a href="#树的定义" class="header-anchor">#</a> 树的定义</h4> <p>D是具有相同特性的数据元素的集合。若D为空集，则称为空树。
否则：</p> <ul><li>在 D 中存在唯一的称为根的数据元素 root</li> <li>当 n&gt;1 时，其余结点可分为 m (m&gt;0) 个互不相交的有限集 T <sub>1</sub> , T<sub>2</sub> , …, T<sub>m</sub> ，其中每一子集本身又是符合本定义的树，称为根root的子树 。</li></ul> <h4 id="基本术语"><a href="#基本术语" class="header-anchor">#</a> 基本术语</h4> <ul><li>结点
<ul><li>数据元素+若干指向子树的分支</li></ul></li> <li>结点的度
<ul><li>分支的个数</li></ul></li> <li>树的度
<ul><li>树中所有结点的度的最大值</li></ul></li> <li>叶子结点
<ul><li>度为零的结点</li></ul></li> <li>分支结点
<ul><li>度大于零的结点</li></ul></li></ul> <div class="language-mermaid extra-class"><pre class="language-text"><code>graph TD
D--&gt;H
D--&gt;I
D--&gt;J
J--&gt;M
</code></pre></div><div class="language-mermaid extra-class"><pre class="language-text"><code>graph TD
A--&gt;B
B--&gt;E
B--&gt;F
F--&gt;K
F--&gt;L
A--&gt;C
C--&gt;G
A--&gt;D
D--&gt;H
D--&gt;I
D--&gt;J
J--&gt;M
</code></pre></div><ul><li>结点的层次：
<ul><li>假设根结点的层次为1 ，第 l 层的结点的子树根结点的层次为 l+1</li></ul></li> <li>树的深度
<ul><li>树中叶子结点所在的最大层次称为树的深度，简称为树的深 ，也称树的高度 ，也可简称为树的高</li></ul></li> <li>(从根到结点的)路径
<ul><li>由从根到该结点所经分支和结点构成</li></ul></li> <li>孩子结点</li> <li>双亲结点</li> <li>兄弟结点</li> <li>堂兄弟结点</li> <li>祖先结点</li> <li>子孙结点</li></ul> <p>森林</p> <p>是m(m≥0)棵互不相交的树的集合</p> <p>任何一棵非空树是一个二元组</p> <ul><li><p>Tree = （root,F)</p> <ul><li>root 被称为根结点</li> <li>F被称为子树森林</li></ul></li> <li><p>有序树</p> <ul><li>子树之间存在确定的次序关系</li></ul></li> <li><p>无序树</p> <ul><li>子树之间不存在确定的次序关系</li></ul></li></ul> <h3 id="二叉树"><a href="#二叉树" class="header-anchor">#</a> 二叉树</h3> <h4 id="二叉树基础"><a href="#二叉树基础" class="header-anchor">#</a> 二叉树基础</h4> <h4 id="二叉树的定义"><a href="#二叉树的定义" class="header-anchor">#</a> 二叉树的定义</h4> <p>二叉树或为空树 ，或是由一个根结点加上两棵分别称为左子树和右子树的、互不交叉的二叉树组成</p> <p><img src="/assets/img/ds_school/img/image-20201028112046627.png" alt="image-20201028112046627"></p> <h4 id="二叉树的五种基本形态"><a href="#二叉树的五种基本形态" class="header-anchor">#</a> 二叉树的五种基本形态</h4> <p><img src="/assets/img/ds_school/img/image-20201028112152219.png" alt="image-20201028112152219"></p> <h4 id="二叉树的主要基本操作"><a href="#二叉树的主要基本操作" class="header-anchor">#</a> 二叉树的主要基本操作</h4> <ol><li><p><code>BinTreeNode&lt;ElemType&gt; *GetRoot() const</code></p> <ul><li>初始条件：二叉树已存在。</li> <li>操作结果：返回二叉树的根。</li></ul></li> <li><p>bool Empty() const</p> <ul><li>初始条件：二叉树已存在。</li> <li>操作结果：如二叉树为空，则返回true ，否则返回false 。</li></ul></li> <li><p>bool GetElem TreeNode ElemType &gt; *cur,ElemType &amp;e) const</p> <ul><li>初始条件：二叉树已存在， cur 为二叉树的一个结点。</li> <li>操作结果：用 e 返回结点 cur 元素值 如果不存在结点 cur,返回 NOT_PRESENT, 否则返回 ENTRY_FOUND 。</li></ul></li> <li><p>bool SetElem TreeNode ElemType &gt; *cur, const ElemType &amp;</p> <ul><li>初始条件：二叉树已存在， cur 为二叉树的一个结点。</li> <li>操作结果：如果存在结点 cur, 则返回 FAIL, 否则返回SUCCESS, 并将结点 cur 的值设置为 e 。</li></ul></li></ol> <h4 id="二叉树的性质"><a href="#二叉树的性质" class="header-anchor">#</a> 二叉树的性质</h4> <ul><li><p>性质1
在二叉树的第<code>i</code>层上至多有 2<sup>i-1</sup> 个结点 。 (i&gt;=1)</p> <ul><li>用归纳法证明
<ul><li>归纳基础:i = 1 层时，最多只有一个根结点：2<sup>i-1</sup>=2<sup>0</sup>=1</li> <li>归纳假设：假设对所有的j, 1 ≤ j &lt; i 命题成立；</li> <li>归纳证明：二叉树上每个结点至多有两棵子树，则第<code>i</code>层的结点数≤ 2<sup>i-2</sup> * 2 = 2<sup>i-1</sup> 。</li></ul></li></ul></li> <li><p>性质2：
高度为 k 的二叉树上至多含 2<sup>k</sup> - 1个结点（ k 1 ）。
证明：
基于上一条性质，高度为 k 的二叉树上的结点数至多为
2<sup>0</sup>+2<sup>1</sup>+...+2<sup>k-1</sup>=2<sup>k</sup>-1。</p></li> <li><p>性质3：
对任何一棵二叉树，若它含有 n<sub>0</sub>个叶子结点、 n<sub>2</sub>个度为2的结点，则必存在关系式：</p> <p>n<sub>0</sub> = n<sub>2</sub> +1
证明：
设结点总数为 n ，度为 1 的结点数为 n<sub>1</sub> ，分支数为b，则有
n = n<sub>0</sub> + n<sub>1</sub> + n<sub>2</sub>
b = n<sub>1</sub> +2n<sub>2</sub>
而b = n<sub>1</sub> = n<sub>0</sub> + n<sub>1</sub> + n<sub>2</sub>-1 由此可得：
n<sub>0</sub> = n<sub>2</sub> + 1 。</p></li></ul> <p>两类特殊的二叉树：</p> <ul><li>满二叉树
指的是深度为 k 且含有 2<sup>k</sup>-1个结点的二叉树。
<img src="/assets/img/ds_school/img/image-20201102081813644.png" alt="image-20201102081813644"></li> <li>完全二叉树:
树中所含的 n 个结点和满二叉树中编号为 1 至 n 的结点一一对应。</li></ul> <p><img src="/assets/img/ds_school/img/image-20201102081911775.png" alt="image-20201102081911775"></p> <ul><li>性质4
具有n 个结点的完全二叉树的深度 为  log 2 n + 1 (向下取整）。
证明：
设完全二叉树的深度为 k
则根据第二条性质得2<sup>k-1</sup> ≤ n &lt; 2<sup>k</sup>
即
k-1 ≤ log<sub>2</sub> n &lt; k
因为
k 只能是整数，因此， k =  log 2 n  + 1 。</li> <li>性质5
若对含n个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：
<ol><li>若 i=1 ，则该结点是二叉树的根，无双亲，否则，编号为  i/2  的结点为其 双亲 结点；</li> <li>若 2i&gt;n ，则该结点无左孩子否则，编号为 2i 的结点为其 左孩子 结点；</li> <li>若 2i+1&gt;n ，则该结点无右孩子结点否则，编号为 2i+1 的结点为其 右孩子 结点 。</li></ol></li></ul> <h2 id="二叉树的性质-2"><a href="#二叉树的性质-2" class="header-anchor">#</a> 二叉树的性质</h2> <ul><li><p>在二叉树的第i层上至多有2<sup>i-1</sup>个结点(i&gt;=1)</p></li> <li><p>深度为k的二叉树至多有2<sup>k</sup>-1个结点(k&gt;=1)</p></li> <li><p>对任何一棵二叉树T，如果其终端结点数n<sub>0</sub>，度为2的结点数位n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1</p></li> <li><p>具有n个结点的完全二叉树的深度为log<sub>2</sub>n」+1（不大于x的最大整数）</p> <ul><li><p>如果对一棵有 n 个结点的完全二叉树(其深度为[log (2) n] + 1) 的结点按层序编号(从第1层到第[log (2) n] + 1 层,每一层从左到右),对任一结点i (1 &lt;= i &lt;= n) 有:</p></li> <li><p>,lo如果 i = 1 ,则结点i是二叉树的根,无双亲;如果i &gt; 1,则其双亲是结点 [ i /2 ];</p></li> <li><p>如果2i &gt; n,则结点i无左孩子(结点i为叶子结点);否则其左孩子是结点2i;</p></li> <li><p>如果2i +1 &gt; n,则结点i无右孩子;否则其右孩子是结点2i +1;</p></li></ul></li></ul> <div class="language-c++ extra-class"><pre class="language-text"><code>#include&lt;iostream&gt;
using namespace std;
struct node
{
	char data;
	node* left=nullptr;
	node* right=nullptr;
};
void CreateBitree(node* &amp;root);
void PreOrderTraverse(node* root);
void InOrderTraverse(node* root);
void PostOrderTraverse(node* root);
int main()
{
rt
	//AB#D##C##
	node* root=new node;
	CreateBitree(root);
	PreOrderTraverse(root);
	cout &lt;&lt; endl;
	InOrderTraverse(root);
	cout &lt;&lt; endl;
	PostOrderTraverse(root);
	cout &lt;&lt; endl;
}
void CreateBitree(node* &amp;root)
{
	char c;
	cin &gt;&gt; c;
	if (c == '#')
		return;
	else
	{
		root = new node;
		root-&gt;data = c;
		root-&gt;left = nullptr;
		root-&gt;right = nullptr;
		CreateBitree(root-&gt;left);
		CreateBitree(root-&gt;right);
	}
}
void PreOrderTraverse(node* root)
{
	if (!root)
		return;
	cout &lt;&lt; root-&gt;data;
	PreOrderTraverse(root-&gt;left);
	PreOrderTraverse(root-&gt;right);
}
void InOrderTraverse(node* root)
{
	if (!root)
		return;
	InOrderTraverse(root-&gt;left);
	cout &lt;&lt; root-&gt;data;
	InOrderTraverse(root-&gt;right);
}
void PostOrderTraverse(node* root)
{
	if (!root)
		return;
	PostOrderTraverse(root-&gt;left);
	PostOrderTraverse(root-&gt;right);
	cout &lt;&lt; root-&gt;data;
}

</code></pre></div><p>无向边用()表示，有向边用&lt;&gt;表示</p> <h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="header-anchor">#</a> 二叉树的存储结构</h4> <ul><li><p>完全二叉树的数组表示</p> <p><img src="/assets/img/ds_school/img/image-20201102082404405.png" alt="image-20201102082404405"></p></li> <li><p>一般二叉树的数组表示</p> <p><img src="/assets/img/ds_school/img/image-20201102082505378.png" alt="image-20201102082505378"></p></li> <li><p>单支树</p> <p><img src="/assets/img/ds_school/img/image-20201102082528334.png" alt="image-20201102082528334"></p> <ul><li>由于一般二叉树必须仿照完全二叉树那样存储，可能会浪费很多存储空间，单支树就是一个极端情况</li></ul></li> <li><p>二叉树的链式存储结构
<img src="/assets/img/ds_school/img/image-20201102082708237.png" alt="image-20201102082708237"></p> <p><img src="/assets/img/ds_school/img/image-20201102082719746.png" alt="image-20201102082719746"></p></li> <li><p>最常使用二叉链表作二叉树的存储结构，下面介绍二叉链表的存储结构</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 二叉树结点类模板</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">BinTreeNode</span>
<span class="token punctuation">{</span>
<span class="token comment">// 数据成员</span>
    ElemType data<span class="token punctuation">;</span> data<span class="token punctuation">;</span><span class="token comment">// 数据域</span>
    BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>leftChild <span class="token punctuation">;</span><span class="token comment">// 左孩子</span>
    BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>rightChild<span class="token punctuation">;</span> <span class="token comment">// 右孩子</span>
<span class="token comment">// 构造函数模板</span>
    <span class="token function">BinTreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 无参构造函数模板</span>
    <span class="token function">BinTreeNode</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>val<span class="token punctuation">,</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>lChild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>rChild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 已知元素值,指向左右孩子构造结点</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 二叉树类模板</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">BinaryTree</span>
<span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
<span class="token comment">// 二叉树的数据成员</span>
	BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>root<span class="token punctuation">;</span>
<span class="token comment">// 辅助函数模板</span>
	BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token function">CopyTreeHelp</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 复制二叉树</span>
    <span class="token keyword">void</span> <span class="token function">DestroyHelp</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span> <span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 销毁以 r 为根二叉树</span>
    <span class="token keyword">void</span> <span class="token function">PreOrderHelp</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>r<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>	<span class="token comment">// 先序遍历</span>
    <span class="token keyword">void</span> <span class="token function">InOrderHelp</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>r<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>	<span class="token comment">// 中序遍历</span>
    <span class="token keyword">void</span> <span class="token function">PostOrderHelp</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>r<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>	<span class="token comment">// 后序遍历</span>
    <span class="token keyword">int</span> <span class="token function">HeightHelp</span><span class="token punctuation">(</span><span class="token keyword">const</span> BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>r<span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>			<span class="token comment">// 返回二叉树的高</span>
    <span class="token keyword">int</span> <span class="token function">NodeCountHelp</span><span class="token punctuation">(</span><span class="token keyword">const</span> BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">*</span>r<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>			<span class="token comment">// 返回二叉树的结点个数</span>
	BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token function">ParentHelp</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>r<span class="token punctuation">,</span><span class="token keyword">const</span> BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>cur<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>	<span class="token comment">// 返回 cur 的双亲</span>
<span class="token keyword">public</span><span class="token operator">:</span>
<span class="token comment">// 二叉树方法声明及重载编译系统默认方法声明</span>
    <span class="token function">BinaryTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>							<span class="token comment">// 无参数的构造函数模板</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">BinaryTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 析构函数模板</span>
    BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token function">GetRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>	<span class="token comment">// 返回二叉树的根</span>
    <span class="token keyword">bool</span> <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>						<span class="token comment">// 判断二叉树是否为空</span>
    <span class="token keyword">bool</span> <span class="token function">GetElem</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">*</span>cur<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>			<span class="token comment">// 用 e 返回结点元素值</span>
    <span class="token keyword">bool</span> <span class="token function">SetElem</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>cur<span class="token punctuation">,</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 将结点 cur的值置为 e</span>
    <span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>				<span class="token comment">// 二叉树的中序遍历</span>
    <span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span><span class="token punctuation">;</span>			<span class="token comment">// 二叉树的先序遍历</span>
    <span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>			<span class="token comment">// 二叉树的后序遍历</span>
    <span class="token keyword">void</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>			<span class="token comment">// 二叉树的层次遍历</span>
    <span class="token keyword">int</span> <span class="token function">NodeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>											<span class="token comment">// 求二叉树的结点个数</span>
    BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token function">LeftChild</span><span class="token punctuation">(</span><span class="token keyword">const</span> BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>cur<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>	<span class="token comment">// 返回二叉树结点 cur 的左孩子</span>
    BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token function">RightChild</span><span class="token punctuation">(</span><span class="token keyword">const</span> BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>cur<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>	<span class="token comment">// 返回二叉树结点 cur 的右孩子</span>
    BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token function">Parent</span><span class="token punctuation">(</span><span class="token keyword">const</span> BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>cur<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>		<span class="token comment">// 返回二叉树结点 cur 的双亲</span>
    <span class="token keyword">void</span> <span class="token function">InsertLeftChild</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">*</span>cur<span class="token punctuation">,</span> <span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 插入左孩子</span>
    <span class="token keyword">void</span> <span class="token function">InsertRightChild</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">*</span>cur<span class="token punctuation">,</span> <span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 插入右孩子</span>
	<span class="token keyword">void</span> <span class="token function">DeleteLeftChild</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">*</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 删除左子树</span>
	<span class="token keyword">void</span> <span class="token function">DeleteRightChild</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">*</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 删除右子树</span>
	<span class="token keyword">int</span> <span class="token function">Height</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>									<span class="token comment">// 求二叉树的高</span>
	<span class="token function">BinaryTree</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>						<span class="token comment">// 建立以 e 为根的二叉树</span>
	<span class="token function">BinaryTree</span><span class="token punctuation">(</span><span class="token keyword">const</span> BinaryTree<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 复制构造函数模板</span>
	<span class="token function">BinaryTree</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 建立以 r 为根的二叉树</span>
	BinaryTree<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> BinaryTree<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">&amp;</span> copy<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 重载赋值运算符</span>
</code></pre></div></li></ul> <h3 id="二叉树遍历"><a href="#二叉树遍历" class="header-anchor">#</a> 二叉树遍历</h3> <h4 id="遍历的定义及遍历算法的实现"><a href="#遍历的定义及遍历算法的实现" class="header-anchor">#</a> 遍历的定义及遍历算法的实现</h4> <ul><li><p>顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次</p></li> <li><p>“访问”的含义可以很广，如：输出结点的信息等</p></li> <li><p>”遍历“是任何类型均有的操作，对线性结构而言，只有一条搜索路径（因为每个结点均只有一个后继），故不需要另加讨论。而二叉树是非线性结构，每个结点最多有两个孩子，则存在如何遍历即按什么样的搜索路径遍历的问题</p></li> <li><p>对“二叉树”而言 可以有三类搜索路径
（1） 先上后下 的按层次遍历
（2） 先左（子树）后右（子树）的遍历
（3） 先右（子树）后左（子树）的遍历</p> <p>设		访问根结点 					记作 V
遍历根的左子树			记作 L</p> <p>​			遍历根的右子树			记作 R
则可能的遍历次序有
前序 VLR 逆前序 VRL
中序 LVR 逆中序 RVL
后序 LRV 逆后序 RLV
层次遍历</p></li></ul> <h4 id="前序遍历-preorder-traversal"><a href="#前序遍历-preorder-traversal" class="header-anchor">#</a> 前序遍历 (Preorder Traversal)</h4> <ul><li>若二叉树为空，则空操作</li> <li>否则
<ul><li>访问根结点 (V)</li> <li>前序遍历左子树 (L)</li> <li>前序遍历右子树 (R)</li></ul></li></ul> <div class="language-CPP extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">PreOrderHelp</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>r<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token comment">// 操作结果：先序遍历以 r 为根的二叉树</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
    	<span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span>r<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// 访问根结点</span>
    	<span class="token function">PreOrderHelp</span><span class="token punctuation">(</span>r<span class="token operator">-&gt;</span>leftChild<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 遍历左子树</span>
    	<span class="token function">PreOrderHelp</span><span class="token punctuation">(</span>r<span class="token operator">-&gt;</span>rightChild<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 遍历右子树</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">PreOrder</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span>ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 操作结果：先序遍历二叉树</span>
<span class="token punctuation">{</span>
	<span class="token function">PreOrderHelp</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> visit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="中序遍历-inorder-traversal"><a href="#中序遍历-inorder-traversal" class="header-anchor">#</a> 中序遍历 (Inorder Traversal)</h4> <ul><li>若二叉树为空，则空操作</li> <li>否则
<ul><li>中序遍历左子树 (L)</li> <li>访问根结点 (V)</li> <li>中序遍历右子树 (R)</li></ul></li></ul> <h4 id="后序遍历-postorder-traversal"><a href="#后序遍历-postorder-traversal" class="header-anchor">#</a> 后序遍历 (Postorder Traversal)</h4> <ul><li>若二叉树为空，则空操作</li> <li>否则
<ul><li>后序遍历左子树 (L)</li> <li>后序遍历右子树 (R)</li> <li>访问根结点 (V)</li></ul></li></ul> <h4 id="层次遍历-levelorder-traversal"><a href="#层次遍历-levelorder-traversal" class="header-anchor">#</a> 层次遍历 (Levelorder Traversal)</h4> <p>从上到下，从左到右</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">LevelOrder</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 操作结果：层次遍历二叉树</span>
<span class="token punctuation">{</span>
    LinkQueue<span class="token operator">&lt;</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token operator">&gt;</span> q<span class="token punctuation">;</span>	<span class="token comment">// 队列</span>
    BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>t <span class="token operator">=</span> root<span class="token punctuation">;</span>		<span class="token comment">// 根</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        q<span class="token punctuation">.</span><span class="token function">InQueue</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>						<span class="token comment">// 如果根非空 则入队</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// q 非空,说明还有结点未访问</span>
        q<span class="token punctuation">.</span><span class="token function">OutQueue</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>leftChild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>		<span class="token comment">// 左孩子非空</span>
        	q<span class="token punctuation">.</span><span class="token function">InQueue</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>leftChild<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 左孩子入队</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>rightChild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>		<span class="token comment">// 右孩子非空</span>
        	q<span class="token punctuation">.</span><span class="token function">InQueue</span><span class="token punctuation">(</span>t <span class="token operator">--</span><span class="token operator">&gt;</span> rightChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 右孩子入队</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="二叉树中序遍历非递归算法的实现"><a href="#二叉树中序遍历非递归算法的实现" class="header-anchor">#</a> 二叉树中序遍历非递归算法的实现</h4> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span> BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span>
<span class="token operator">*</span><span class="token function">GoFarLeft</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>r<span class="token punctuation">,</span>LinkStack<span class="token operator">&lt;</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：返回以r为根的二叉树的最左侧的结点</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> 
        <span class="token comment">// 空二叉树</span>
    	<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span> 
        <span class="token comment">// 非空二叉树</span>
    	BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>cur <span class="token operator">=</span> r<span class="token punctuation">;</span>		<span class="token comment">//当前结点</span>
    	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>leftChild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    	<span class="token punctuation">{</span> 
            <span class="token comment">// cur存在左孩子,则cur移向左孩子</span>
            s<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span> 					<span class="token comment">// cur入栈</span>
            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>leftChild<span class="token punctuation">;</span>			<span class="token comment">// cur移向左孩子</span>
    	<span class="token punctuation">}</span>
    <span class="token keyword">return</span> cur<span class="token punctuation">;</span> 	<span class="token comment">// cur为最左侧的结点</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">NonRecurInOrder</span><span class="token punctuation">(</span><span class="token keyword">const</span> BinaryTree<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">&amp;</span>bt<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 操作结果：中序遍历以r为根的二叉树</span>
<span class="token punctuation">{</span>
    BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>cur<span class="token punctuation">;</span> <span class="token comment">// 当前结点</span>
    LinkStack<span class="token operator">&lt;</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token operator">&gt;</span> s<span class="token punctuation">;</span>
    cur <span class="token operator">=</span> GoFarLeft <span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token punctuation">(</span>bt<span class="token punctuation">.</span><span class="token function">GetRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// cur为以r为根的二叉树的最左侧的结点</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> 
        <span class="token comment">// 处理当前结点</span>
    	<span class="token punctuation">(</span><span class="token operator">*</span>visit<span class="token punctuation">)</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> 		<span class="token comment">// 访问当前结点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>rightChild <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span> 
            <span class="token comment">// cur的中序序列后继为右子树的最左侧的结点</span>
        	cur <span class="token operator">=</span> <span class="token function">GoFarLeft</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>rightChild<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span> 
            <span class="token comment">// cur的中序序列后继为栈s的栈顶结点</span>
            s<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取出栈顶结点</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span> 
            <span class="token comment">// 栈s为空,无中序序列后继</span>
            cur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 无中序序列后继</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</code></pre></div><h4 id="由中缀表达式建立对应的二叉树"><a href="#由中缀表达式建立对应的二叉树" class="header-anchor">#</a> 由中缀表达式建立对应的二叉树</h4> <p>对应中缀表达式 (a+b)×c-d/e 的二叉树</p> <p><img src="/assets/img/ds_school/img/image-20201109164538401.png" alt="image-20201109164538401"></p> <p>特点：</p> <ul><li>操作数为叶子结点</li> <li>运算符为分支结点</li></ul> <p>分析表达式和二叉树的关系</p> <p><img src="/assets/img/ds_school/img/image-20201109164628587.png" alt="image-20201109164628587"></p> <h4 id="二叉树的计数"><a href="#二叉树的计数" class="header-anchor">#</a> 二叉树的计数</h4> <p>问题是有n个数据值，可能构造 多少种不同的二叉树？这就是二叉树 的计数问题。</p> <p>有0个, 1个, 2个, 3个结点的不同二叉树如下</p> <p><img src="/assets/img/ds_school/img/image-20201109164710873.png" alt="image-20201109164710873"></p> <p>计算具有n个结点的不同二叉树的棵数</p> <p>卡特兰（Catalan）公式</p> <p><img src="/assets/img/ds_school/img/image-20201109164745523.png" alt="image-20201109164745523"></p> <p>具有4个结点的不同二叉树</p> <p><img src="/assets/img/ds_school/img/image-20201109164756811.png" alt="image-20201109164756811"></p> <h4 id="遍历算法的应用举例"><a href="#遍历算法的应用举例" class="header-anchor">#</a> 遍历算法的应用举例</h4> <h5 id="统计二叉树中结点的个数"><a href="#统计二叉树中结点的个数" class="header-anchor">#</a> 统计二叉树中结点的个数</h5> <p>算法基本思想:</p> <ul><li>二叉树的结点个数等于左子树的结点 数加上右子树的结点数再加上根结点数1， 因此求二叉树的结点数的问题可以分解为计算其左右子树的结点数目问题</li></ul> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">NodeCountHelp</span><span class="token punctuation">(</span><span class="token keyword">const</span> BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>r<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token comment">// 操作结果：返回以r为根的二叉树的结点个数</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> 
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 空二叉数结点个数为0</span>
    <span class="token keyword">else</span> 
        <span class="token keyword">return</span> <span class="token function">NodeCountHelp</span><span class="token punctuation">(</span>r<span class="token operator">-&gt;</span>leftChild<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">NodeCountHelp</span><span class="token punctuation">(</span>r<span class="token operator">-&gt;</span>rightChild<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 结点个为左右子树的结点数和再加1</span>
<span class="token punctuation">}</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">NodeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token comment">// 操作结果：返回二叉树的结点个数</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">NodeCountHelp</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="求二叉树的高"><a href="#求二叉树的高" class="header-anchor">#</a> 求二叉树的高</h5> <p>算法基本思想: 首先分析二叉树的高和它的左、右子树高之间的关系。</p> <p>从二叉树高的定义可知，二叉树的高应为其左、右子树高的最大值加1。由此，需先分别求得左、右子树的高，算法中 “访问结点”的操作为：求得左、右子树高的最大值，然后加 1 。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">HeightHelp</span><span class="token punctuation">(</span><span class="token keyword">const</span> BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>r<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token comment">// 操作结果：返回以r为根的二叉树的高</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 空二叉树高为0</span>
    	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
	<span class="token punctuation">{</span> 
        <span class="token comment">// 非空二叉树高为左右子树高的最大值再加1</span>
        <span class="token keyword">int</span> lHeight<span class="token punctuation">,</span> rHeight<span class="token punctuation">;</span>
        lHeight <span class="token operator">=</span> <span class="token function">HeightHelp</span><span class="token punctuation">(</span>r<span class="token operator">-&gt;</span>leftChild<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//左子树高</span>
        rHeight<span class="token operator">=</span><span class="token function">HeightHelp</span><span class="token punctuation">(</span>r<span class="token operator">-&gt;</span>rightChild<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//右子树高</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>lHeight <span class="token operator">&gt;</span> rHeight <span class="token operator">?</span> lHeight <span class="token operator">:</span> rHeight<span class="token punctuation">)</span><span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 高为左右子树高的最大值加1</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">Height</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token comment">// 操作结果：返回二叉树的高</span>
<span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">HeightHelp</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="二叉树的复制"><a href="#二叉树的复制" class="header-anchor">#</a> 二叉树的复制</h5> <p>首先讨论二叉树复制其基本操作为：生成一个结点。</p> <p><img src="/assets/img/ds_school/img/image-20201109165231146.png" alt="image-20201109165231146"></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">CopyTreeHelp</span> <span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>r<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：将以r为根的二叉树复制成新的二叉树,返回新二叉树的根</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> 
        <span class="token comment">// 复制空二叉树</span>
    	<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 空二叉树根为空</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span> 	<span class="token comment">// 复制非空二叉树</span>
        BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>lChild <span class="token operator">=</span> <span class="token function">CopyTree</span><span class="token punctuation">(</span>r<span class="token operator">-&gt;</span>leftChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 复制左子树</span>
		BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>rChild <span class="token operator">=</span> <span class="token function">CopyTree</span><span class="token punctuation">(</span>r<span class="token operator">-&gt;</span>rightChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 复制右子树</span>
		BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>r <span class="token operator">=</span> <span class="token keyword">new</span> BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token punctuation">(</span>r<span class="token operator">-&gt;</span>data<span class="token punctuation">,</span> lChild<span class="token punctuation">,</span>rChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 复制根结点</span>
		<span class="token keyword">return</span> r<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token class-name">BinaryTree</span><span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">BinaryTree</span><span class="token punctuation">(</span><span class="token keyword">const</span>
BinaryTree<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>copy<span class="token punctuation">)</span>
<span class="token comment">//操作结果:由已知二叉树构造新二叉树——复制构造函数</span>
<span class="token punctuation">{</span>
	root <span class="token operator">=</span> <span class="token function">CopyTreeHelp</span><span class="token punctuation">(</span>copy<span class="token punctuation">.</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 复制二叉树</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="建立二叉树的存储结构"><a href="#建立二叉树的存储结构" class="header-anchor">#</a> 建立二叉树的存储结构</h5> <p>由二叉树的先序和中序序列建立二叉树</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">CreateBinaryTreeHelp</span><span class="token punctuation">(</span>BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token operator">*</span><span class="token operator">&amp;</span>r<span class="token punctuation">,</span> ElemType pre<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ElemType in<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> preLeft<span class="token punctuation">,</span><span class="token keyword">int</span> preRight<span class="token punctuation">,</span> <span class="token keyword">int</span> inLeft<span class="token punctuation">,</span> <span class="token keyword">int</span> inRight<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：已知二叉树的先序序列pre[preLeft..preRight]和中序序列in[inLeft..inRight]构造以r为树的二叉树</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>preLeft <span class="token operator">&gt;</span> preRight <span class="token operator">||</span> inLeft <span class="token operator">&gt;</span> inRight <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 二叉树无结点,空二叉树</span>
    	r <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 空二叉树根为空</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
	<span class="token punctuation">{</span>
        <span class="token comment">// 二叉树有结点,非空二叉树</span>
        r <span class="token operator">=</span> <span class="token keyword">new</span> BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token punctuation">(</span>pre<span class="token punctuation">[</span>preLeft<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 生成根结点</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> inLeft<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>in<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">!=</span> pre<span class="token punctuation">[</span>preLeft<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span> 
            <span class="token comment">// 查找pre[preLeft]在in[]中的位置也就是中序序列中根的位置</span>
        	mid<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">CreateBinaryTreeHelp</span><span class="token punctuation">(</span>r<span class="token operator">-&gt;</span>leftChild<span class="token punctuation">,</span> pre<span class="token punctuation">,</span> in<span class="token punctuation">,</span>preLeft<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> preLeft <span class="token operator">+</span> mid <span class="token operator">-</span> inLeft<span class="token punctuation">,</span>inLeft<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 生成左子树</span>
        <span class="token function">CreateBinaryTreeHelp</span><span class="token punctuation">(</span>r<span class="token operator">-&gt;</span>rightChild<span class="token punctuation">,</span> pre<span class="token punctuation">,</span> in<span class="token punctuation">,</span>preLeft <span class="token operator">+</span> mid <span class="token operator">-</span> inLeft <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preRight<span class="token punctuation">,</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inRight<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 生成右子树</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ElemType</span><span class="token operator">&gt;</span>
BinaryTree<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span><span class="token function">CreateBinaryTree</span><span class="token punctuation">(</span>ElemType pre<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ElemType in<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token comment">// 操作结果：已知先序和中序序列构造二叉树</span>
<span class="token punctuation">{</span>
    BinTreeNode<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span> <span class="token operator">*</span>r<span class="token punctuation">;</span> 	<span class="token comment">// 二叉树的根</span>
    CreateBinaryTreeHelp<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> pre<span class="token punctuation">,</span> in<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 由先序和中序序列构造以r为根的二叉树</span>
    <span class="token keyword">return</span> BinaryTree<span class="token operator">&lt;</span>ElemType<span class="token operator">&gt;</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 返回以r为根的二叉树</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="线索二叉树"><a href="#线索二叉树" class="header-anchor">#</a> 线索二叉树</h3> <p>遍历二叉树的结果是， 求得结点的一个线性序列</p> <p><img src="/assets/img/ds_school/img/image-20201109173030751.png" alt="image-20201109173030751"></p> <p>指向该线性序列中的“前驱”和 “后继” 的指针，称作“线索”</p> <ul><li>包含 “线索” 的存储结构，称作 “线索链表”</li> <li>与其相应的二叉树， 称作 “线索二叉树”</li></ul> <p>对线索链表中结点的约定</p> <p>在二叉链表的结点中增加两个标志域 leftTag和rightTag,并作如下规定:</p> <ul><li>若该结点的左子树不空，leftChild域 的指针指向其左孩子，且左标志 leftTag的值为0</li> <li>否则leftChild域的指针指向其“前 驱”，且左标志leftTag的值为1</li></ul> <table><tr><td>leftChild</td> <td>leftTag</td> <td>data</td> <td>rightTag</td> <td>rightChild</td></tr></table> <p>若该结点的右子树不空</p> <ul><li>则rightChild域的指针指向其右孩子， 且右标志rrighTag的值为0</li> <li>否则，rightChild域的指针指向其“后继”，且右标志rightTag的值为1,如此定义的二叉树的存储结构称作 “线索链表&quot;</li></ul> <p>中序线索二叉树</p> <p><img src="/assets/img/ds_school/img/image-20201109173843398.png" alt="image-20201109173843398"></p> <p>不带表头结点的中序线索二叉树示意图</p> <p><img src="/assets/img/ds_school/img/image-20201109173901787.png" alt="image-20201109173901787"></p> <p>带表头结点的中序线索二叉树 示意图</p> <p><img src="/assets/img/ds_school/img/image-20201109173915126.png" alt="image-20201109173915126"></p> <h3 id="树和森林"><a href="#树和森林" class="header-anchor">#</a> 树和森林</h3> <h4 id="树的存储结构"><a href="#树的存储结构" class="header-anchor">#</a> 树的存储结构</h4> <ol><li>双亲表示法</li></ol> <p><img src="/assets/img/ds_school/img/image-20201109210633359.png" alt="image-20201109210633359"></p> <ol start="2"><li>孩子链表表示法</li></ol> <p><img src="/assets/img/ds_school/img/image-20201109210724787.png" alt="image-20201109210724787"></p> <ol start="3"><li><p>孩子兄弟表示法</p> <p><img src="/assets/img/ds_school/img/image-20201109210758240.png" alt="image-20201109210758240"></p></li></ol> <p><img src="/assets/img/ds_school/img/image-20201109210815959.png" alt="image-20201109210815959"></p> <p>由此，树的各种操作均可对应二叉树的操作来完成。</p> <p>应当注意的是，和树对应的二叉树，其左、右孩子的概念已改变为： 左是树中第一个孩子， 右是树中下一个兄弟。</p> <h4 id="森林与二叉树的转换"><a href="#森林与二叉树的转换" class="header-anchor">#</a> 森林与二叉树的转换</h4> <ul><li>森林由三部分构成
<ol><li>森林中第一棵树的根结点</li> <li>森林中第一棵树的子树森林</li> <li>森林中其它树构成的森林</li></ol></li></ul> <ol><li><p>森林转化成二叉树的规则</p> <p>设二叉树B的根为root(B)，左子树为LB，右子树为RB，森林F由树T<sub>1</sub> ,T<sub>2</sub> ,…,T<sub>n</sub>组成。</p> <ul><li>若F为空，即n = 0，则对应的二叉树B为空二叉树</li> <li>若F不空，则对应二叉树B的根root(B) 是F中第一棵树T<sub>1</sub>的根root(T<sub>1</sub>)，其左子树LB由(T<sub>11</sub>, T<sub>12</sub>, …, T<sub>1m</sub>)转化而来，其中T<sub>11</sub>, T<sub>12</sub>,…, T<sub>1m</sub>是root(T<sub>1</sub> )的子树；其右子树RB 由(T<sub>2</sub> , T<sub>3</sub> , …, T<sub>n</sub> )转化而来，其中，T<sub>2</sub> ,T<sub>3</sub> ,… , T<sub>n</sub>是除T<sub>1</sub>外其它树构成的森林</li></ul></li> <li><p>二叉树转换为森林的规则</p> <p>设二叉树B的根为root(B)，左子树为LB，右子树为RB，森林F由树T<sub>1</sub> ,T<sub>2</sub> ,…,T<sub>n</sub>组成。</p> <ul><li>如果B为空，则对应的森林F也为空</li> <li>如果B非空，则F中第一棵树T<sub>1</sub>的根为root(B)；T1的根 的子树森林(T<sub>11</sub>, T<sub>12</sub>, …, T<sub>1m</sub> ) 是由 root(B)的左子树LB转换而来，F 除了T<sub>1</sub>之外其余的树组成的森林(T<sub>2</sub> , T<sub>3</sub> , …, T<sub>n</sub> )是由root(B)的右子树RB转换而成的森林</li></ul></li> <li><p>森林与二叉树的转换示例</p> <p><img src="/assets/img/ds_school/img/image-20201109220432675.png" alt="image-20201109220432675"></p></li></ol> <h5 id="树、森林与二叉树的转换-大话"><a href="#树、森林与二叉树的转换-大话" class="header-anchor">#</a> 树、森林与二叉树的转换（大话）</h5> <h6 id="树转换为二叉树"><a href="#树转换为二叉树" class="header-anchor">#</a> 树转换为二叉树</h6> <ol><li>加线
<ul><li>在所有兄弟结点之间加一条线。</li></ul></li> <li>去线
<ul><li>对树中的每个节点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</li></ul></li> <li>层次调整
<ul><li>以树的根节点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。
<strong>注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子</strong></li></ul></li></ol> <p><img src="/assets/img/ds_school/img/image-20201110202444986.png" alt="image-20201110202444986"></p> <h6 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="header-anchor">#</a> 森林转换为二叉树</h6> <p>森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。步骤如下:</p> <ol><li>把每棵树转化为二叉树。</li> <li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根节点作为前一棵二叉树的根节点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</li></ol> <p><img src="/assets/img/ds_school/img/image-20201110202923606.png" alt="image-20201110202923606"></p> <h6 id="二叉树转换为树"><a href="#二叉树转换为树" class="header-anchor">#</a> 二叉树转换为树</h6> <ol><li>加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子节点。。。左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子连接起来。</li> <li>去线。删除原二叉树中所有节点与其右孩子结点的连线</li> <li>层次调整。使之结构层次分明。</li></ol> <p><img src="/assets/img/ds_school/img/image-20201110203404374.png" alt="image-20201110203404374"></p> <p>二叉树转换为森林</p> <p>判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。那么如果是转换成森林，步骤如下:</p> <ol><li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在,则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。</li> <li>再将每棵分离后的二叉树转换为树即可。</li></ol> <p><img src="/assets/img/ds_school/img/image-20201110203611894.png" alt="image-20201110203611894"></p> <h4 id="树的遍历"><a href="#树的遍历" class="header-anchor">#</a> 树的遍历</h4> <ul><li>树的先根遍历
<ul><li>若树为空，则空操作，结束；否则按如下规则遍历：
<ol><li>访问根结点；</li> <li>分别先根遍历根的各棵子树。</li></ol></li></ul></li> <li>树的后根遍历
<ul><li>若树为空，则空操作，结束；否则按如下规则遍历：
<ol><li>分别后根遍历根的各棵子树；</li> <li>访问根结点。</li></ol></li></ul></li></ul> <div class="language-mermaid extra-class"><pre class="language-text"><code>graph TD
A--&gt;B
B--&gt;E
B--&gt;F
A--&gt;C
A--&gt;D
D--&gt;G--&gt;H--&gt;I
H--&gt;J
H--&gt;K
</code></pre></div><ul><li>先根次序遍历 A B E F C D G H I J K</li> <li>后根次序遍历 E F B C I J K H G D A</li></ul> <h4 id="森林的遍历"><a href="#森林的遍历" class="header-anchor">#</a> 森林的遍历</h4> <ul><li><p>森林的先根遍历</p> <p>若森林F为空, 返回</p> <p>否则:</p> <ul><li>访问F的第一棵树的根结点</li> <li>先根次序遍历第一棵树的子树森林</li> <li>先根次序遍历其它树组成的森林</li></ul></li> <li><p>森林的中根遍历</p> <p>若森林F为空，返回</p> <p>否则:</p> <ul><li>中根次序遍历第一棵树的子树森林</li> <li>访问F的第一棵树的根结点</li> <li>中根次序遍历其它树组成的森林</li></ul></li></ul> <h4 id="二叉树、树、森林三者遍历比较"><a href="#二叉树、树、森林三者遍历比较" class="header-anchor">#</a> 二叉树、树、森林三者遍历比较</h4> <h5 id="三种遍历方法对比"><a href="#三种遍历方法对比" class="header-anchor">#</a> 三种遍历方法对比</h5> <table><thead><tr><th>二叉树</th> <th>二叉树</th> <th>树</th> <th>森林</th></tr></thead> <tbody><tr><td>先序遍历</td> <td>第一次经过该结点就访问</td> <td>根访问在前，先访问根结点，后访问其他结点</td> <td>从左到右对森林中的每一棵树进行【先根遍历】</td></tr> <tr><td>中序遍历</td> <td>第二次经过结点的时候访问</td> <td>树的度不一定，一般不说中序遍历，但非要谈，那就是<strong>第二次经过该结点时进行访问</strong></td> <td>森林的中序、后序，只是许多地方说法不一样，实则是一个东西</td></tr> <tr><td>后序遍历</td> <td>第三次经过结点的时间访问</td> <td>先遍历子树，再访问根结点（先访问子树是空的结点）</td> <td>从左到右对森林中的每一棵树进行【后根遍历】</td></tr></tbody></table> <ul><li>若树是用二叉链表的形式存储，那么树的后根遍历，即可对该二叉链表进行中序遍历即可</li></ul> <table><thead><tr><th>树</th> <th>森林</th> <th>树、森林用二叉链表的形式存储（孩子兄弟表示法）</th></tr></thead> <tbody><tr><td>先根遍历</td> <td>先序遍历</td> <td>先序遍历</td></tr> <tr><td>后根遍历</td> <td>中序遍历、后序遍历</td> <td>中序遍历</td></tr></tbody></table> <h3 id="哈夫曼树与哈夫曼编码"><a href="#哈夫曼树与哈夫曼编码" class="header-anchor">#</a> 哈夫曼树与哈夫曼编码</h3> <h4 id="哈夫曼树的基本概念"><a href="#哈夫曼树的基本概念" class="header-anchor">#</a> 哈夫曼树的基本概念</h4> <ul><li>结点间路径长度(Path Length)：连接两结点的路径上的分支数</li> <li>结点的路径长度：从根结点到该结点的路径上分支的数目</li> <li>树的路径长度：树中每个结点的路径长度之和</li> <li>树的带权路径长度 (Weighted Path Length, WPL)：树的各叶结点所带的权值与该 结点到根的路径长度的乘积的和</li></ul> <p><img src="/assets/img/ds_school/img/image-20201109221435076.png" alt="image-20201109221435076"></p> <ul><li>哈夫曼树：在所有含n个叶子结点、并带相同权值的m叉树中，必存在一棵其带权路径长度取最小值的树，称为 “最优树” , 或“哈夫曼树” (Huffman Tree)</li> <li>具有不同带权路径长度的二叉树</li></ul> <p><img src="/assets/img/ds_school/img/image-20201109221531962.png" alt="image-20201109221531962"></p> <center>WPL(T)= 7×2×2+2×3+ 4×3+9×2=60</center> <p><img src="/assets/img/ds_school/img/image-20201109221657694.png" alt="image-20201109221657694"></p> <center>WPL(T)= 7×4+9×4+5×3+ 4×2+2×1=89 </center> <p>哈夫曼树中，权值越大的结点离根越近</p> <h4 id="构造哈夫曼树的算法-以二叉树为例"><a href="#构造哈夫曼树的算法-以二叉树为例" class="header-anchor">#</a> 构造哈夫曼树的算法 (以二叉树为例)</h4> <ol><li>根据给定的 n 个权值 {w<sub>1</sub> , w<sub>2</sub>, …, w<sub>n</sub>}，构造 n 棵二叉树的集合 F = {T<sub>1</sub> , T<sub>2 </sub>, … , T<sub>n</sub>}， 其中二叉树T<sub>i</sub>中均只含一个带权值为 w<sub>i</sub> 的根结点，其左、右子树为空树(i=1，2，…，n)；</li> <li>在 F 中选取其根结点的权值为最小的两棵二叉树，分别作为左、 右子树构造一棵新的二叉树，并置这棵新的二叉树根结点的权值为其左、右子树根结点的权值之和；</li> <li>从F中删去这两棵树，同时加入刚生成的新树</li> <li>重复 (2) 和 (3) 两步，直至 F 中只含一棵树为止</li></ol> <h4 id="前缀编码"><a href="#前缀编码" class="header-anchor">#</a> 前缀编码</h4> <p>任何一个字符的编码都不是同一字符集中另一个字符的编码的前缀</p> <p>利用哈夫曼树可以构造一种不等 长的二进制编码，并且构造所得的哈 夫曼编码是一种最优前缀编码，使得 编码的总长度最短</p> <p><img src="/assets/img/ds_school/img/image-20201109222142933.png" alt="image-20201109222142933"></p> <div class="language- extra-class"><pre class="language-text"><code>设给出一段报文
CAST CAST SAT AT A TASA
字符集合是 { C, A, S, T }，各个字符
出现的频度(次数)是 W＝{ 2, 7, 4, 5 }
若给每个字符以等长编码
A : 00 T : 10 C : 01 S : 11
则总编码长度为2*2+7*2+4*2+5*2=36
</code></pre></div><p>以各字符出现概率{2,7,4,5}为各叶结 权值，建立哈夫曼树，得哈夫曼编码(不 等长编码) A:0 T:10 C:110 S:111 总编码长度为 7<em>1+5</em>2+2<em>3+4</em>3=35 总编码长度正好等于哈夫曼树的带权路径长度WPL</p> <p><img src="/assets/img/ds_school/img/image-20201109222237146.png" alt="image-20201109222237146"></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">2021年1月26日星期二晚上11点38分</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a5ec0a2d.js" defer></script><script src="/assets/js/2.785c97dd.js" defer></script><script src="/assets/js/22.01a3eb25.js" defer></script>
  </body>
</html>
